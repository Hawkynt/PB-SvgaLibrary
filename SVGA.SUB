' =============================================================================
' SVGA.SUB - Main SVGA Graphics Library
' =============================================================================
' Modular SVGA graphics library for Power BASIC 3.5
' Provides comprehensive graphics functions for VESA modes, image handling,
' font rendering, and memory management
' =============================================================================
' Author: Hawkynt
' License: LGPL 3.0
' =============================================================================

' Include all module files
$INCLUDE "TYPES.SUB"      ' Type definitions and global variables
$INCLUDE "TIMER.SUB"      ' High-precision timer system
$INCLUDE "VGA.SUB"        ' Standard VGA graphics functions
$INCLUDE "MODEX.SUB"      ' Mode-X graphics functions
$INCLUDE "VESA.SUB"       ' VESA graphics mode management
$INCLUDE "VIRTUAL.SUB"    ' Virtual coordinate system management
$INCLUDE "GRAPHICS.SUB"   ' Core drawing primitives
$INCLUDE "MEMORY.SUB"     ' EMS & Memory management
$INCLUDE "FONTS.SUB"      ' Font loading and text rendering
$INCLUDE "CURSOR.SUB"     ' Advanced cursor management
$INCLUDE "SPRITE.SUB"     ' Sprite management and collision detection
$INCLUDE "SCROLL.SUB"     ' Screen scrolling routines
$INCLUDE "DRAW_ICO.SUB"   ' ICO image format support
$INCLUDE "DRAW_CUR.SUB"   ' CUR cursor format support
$INCLUDE "DRAW_ANI.SUB"   ' ANI animated cursor support
$INCLUDE "DRAW_BMP.SUB"   ' BMP image format drawing
$INCLUDE "DRAW_PCX.SUB"   ' PCX image format drawing
$INCLUDE "DRAW_TIF.SUB"   ' TIFF image format support
$INCLUDE "DRAW_TGA.SUB"   ' TGA image format support
$INCLUDE "DRAW_GIF.SUB"   ' GIF image format support
$INCLUDE "DRAW_ICL.SUB"   ' Windows DLL icon library support

' =============================================================================
' Initialize SVGA library
' Parameters: None
' Returns: Nothing
' Note: Call this before using any other library functions
' =============================================================================
SUB Svga_Init
    ' Initialize all context structures
    CALL Types_InitializeSvgaContexts
    
    ' Initialize timer system for animations
    CALL Timer_Init
    
    ' Initialize cursor management system
    CALL Cursor_Init
    
    ' Initialize sprite system
    CALL Sprite_InitSprites
    
    ' Initialize scrolling system
    CALL Scroll_InitScroll
    
    ' Initialize Mode-X performance lookup tables
    CALL ModeX_InitTables
    
    ' Initialize dispatch table with default (Mode 13h) function pointers
    CALL Svga_InitDispatchTable
    
    ' Set default values
    SVGAScreenContext.XRes = 0
    SVGAScreenContext.YRes = 0
    SVGAScreenContext.ColorDepth = 0
    SVGAScreenContext.WindowNumber = 0
    
    VESASystemContext.XRes = 0
    VESASystemContext.YRes = 0
    VESASystemContext.Window = 0
    VESASystemContext.OneLoadOnly = 0
    VESASystemContext.TransparentColor = 0
    VESASystemContext.BMPMode = 0
    
    WindowSystemContext.Current = 0
    
    FontSystemContext.Data = ""
    FontSystemContext.CharWidth = 8
    FontSystemContext.CharHeight = 8
    FontSystemContext.LoadPath = ""
    
    ScaleSystemContext.XScale = 1
    ScaleSystemContext.YScale = 1
    ScaleSystemContext.KScale = 1
END SUB

' =============================================================================
' Initialize dispatch table with function pointers based on current mode
' Parameters: None
' Returns: Nothing
' Note: Must be called after mode is set to update function pointers
' =============================================================================
SUB Svga_InitDispatchTable
    SELECT CASE VESASystemContext.CurrentMode
        CASE %SVGA_MODEX
            SVGADispatch.PutPixel = CODEPTR(ModeX_PutPixel)
            SVGADispatch.GetPixel = CODEPTR(ModeX_GetPixel)
            SVGADispatch.HLine = CODEPTR(ModeX_HLine)
            SVGADispatch.VLine = CODEPTR(ModeX_VLine)
            SVGADispatch.LineDraw = CODEPTR(ModeX_LineDraw)
            SVGADispatch.FillRect = CODEPTR(ModeX_FillRect)
            SVGADispatch.DrawRect = CODEPTR(ModeX_DrawRect)
            SVGADispatch.DrawCircle = CODEPTR(ModeX_DrawCircle)
            SVGADispatch.FillCircle = CODEPTR(ModeX_FillCircle)
            SVGADispatch.ClearScreen = CODEPTR(ModeX_ClearScreen)
            SVGADispatch.CopyBlock = CODEPTR(ModeX_CopyBlock)
            
        CASE %SVGA_VESA
            SVGADispatch.PutPixel = CODEPTR(Vesa_PutPixel)
            SVGADispatch.GetPixel = CODEPTR(Vesa_GetPixel)
            SVGADispatch.HLine = CODEPTR(Vesa_HLine)
            SVGADispatch.VLine = CODEPTR(Vesa_VLine)
            SVGADispatch.LineDraw = CODEPTR(Vesa_LineDraw)
            SVGADispatch.FillRect = CODEPTR(Vesa_FillRect)
            SVGADispatch.DrawRect = CODEPTR(Vesa_DrawRect)
            ' VESA doesn't have optimized circle functions - use NULL pointers
            SVGADispatch.DrawCircle = 0
            SVGADispatch.FillCircle = 0
            SVGADispatch.ClearScreen = CODEPTR(Vesa_ClearScreen)
            SVGADispatch.CopyBlock = CODEPTR(Vesa_CopyBlock)
            
        CASE %SVGA_MODE13, ELSE
            SVGADispatch.PutPixel = CODEPTR(Vga_PutPixel)
            SVGADispatch.GetPixel = CODEPTR(Vga_GetPixel)
            SVGADispatch.HLine = CODEPTR(Vga_HLine)
            SVGADispatch.VLine = CODEPTR(Vga_VLine)
            SVGADispatch.LineDraw = CODEPTR(Vga_LineDraw)
            SVGADispatch.FillRect = CODEPTR(Vga_FillRect)
            SVGADispatch.DrawRect = CODEPTR(Vga_DrawRect)
            SVGADispatch.DrawCircle = CODEPTR(Vga_DrawCircle)
            SVGADispatch.FillCircle = CODEPTR(Vga_FillCircle)
            SVGADispatch.ClearScreen = CODEPTR(Vga_ClearScreen)
            SVGADispatch.CopyBlock = CODEPTR(Vga_CopyBlock)
    END SELECT
END SUB

' =============================================================================
' Core pixel manipulation functions
' =============================================================================

' =============================================================================
' Set a single pixel on screen
' Parameters:
'   X, Y - Pixel coordinates (BYVAL)
'   Color - Pixel color value (BYVAL)
' Returns: Nothing
' Note: Dispatcher function that calls appropriate mode-specific implementation
' =============================================================================
SUB Svga_PutPixel(BYVAL x AS WORD, BYVAL y AS WORD, BYVAL color AS BYTE)
    DIM PhysicalX AS WORD, PhysicalY AS WORD
    
    ' Convert virtual coordinates to physical coordinates
    CALL Virtual_ToPhysical(x, y, PhysicalX, PhysicalY)
    
    ' Check viewport clipping using virtual coordinates
    IF Virtual_IsVisible(x, y) = 0 THEN EXIT SUB
    
    ' Use function pointer for ultra-fast dispatch
    IF SVGADispatch.PutPixel <> 0 THEN
        CALL DWORD SVGADispatch.PutPixel USING ModeX_PutPixel(PhysicalX, PhysicalY, color)
    END IF
END SUB

' =============================================================================
' Get a single pixel color from screen
' Parameters:
'   X, Y - Pixel coordinates (BYVAL)
' Returns: Pixel color value
' =============================================================================
FUNCTION Svga_GetPixel (BYVAL x AS WORD, BYVAL y AS WORD) AS BYTE
    DIM PhysicalX AS WORD, PhysicalY AS WORD
    
    ' Convert virtual coordinates to physical coordinates
    CALL Virtual_ToPhysical(x, y, PhysicalX, PhysicalY)
    
    ' Check viewport clipping using virtual coordinates
    IF Virtual_IsVisible(x, y) = 0 THEN
        Svga_GetPixel = 0  ' Return black for clipped pixels
        EXIT FUNCTION
    END IF
    
    ' Use function pointer for ultra-fast dispatch
    IF SVGADispatch.GetPixel <> 0 THEN
        Svga_GetPixel = DWORD SVGADispatch.GetPixel USING ModeX_GetPixel(PhysicalX, PhysicalY)
    ELSE
        Svga_GetPixel = 0
    END IF
END FUNCTION

' =============================================================================
' Draw a line between two points
' Parameters:
'   X1, Y1 - Starting point coordinates (BYVAL)
'   X2, Y2 - Ending point coordinates (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' Note: Dispatcher function that calls appropriate mode-specific implementation
' =============================================================================
SUB Svga_LineDraw(BYVAL x1 AS WORD, BYVAL y1 AS WORD, BYVAL x2 AS WORD, BYVAL y2 AS WORD, BYVAL color AS LONG)
    DIM PhysicalX1 AS WORD, PhysicalY1 AS WORD, PhysicalX2 AS WORD, PhysicalY2 AS WORD
    
    ' Convert virtual coordinates to physical coordinates
    CALL Virtual_ToPhysical(x1, y1, PhysicalX1, PhysicalY1)
    CALL Virtual_ToPhysical(x2, y2, PhysicalX2, PhysicalY2)
    
    ' Basic clipping check (more sophisticated clipping could be added)
    IF Virtual_IsVisible(x1, y1) = 0 AND Virtual_IsVisible(x2, y2) = 0 THEN EXIT SUB
    
    ' Use function pointer for ultra-fast dispatch
    IF SVGADispatch.LineDraw <> 0 THEN
        CALL DWORD SVGADispatch.LineDraw USING ModeX_LineDraw(PhysicalX1, PhysicalY1, PhysicalX2, PhysicalY2, color)
    END IF
END SUB

' =============================================================================
' Clear entire screen to specified color
' Parameters:
'   Color - Fill color (BYVAL, optional - defaults to 0/black)
' Returns: Nothing
' Note: Dispatcher function that calls appropriate mode-specific implementation
' =============================================================================
SUB Svga_ClearScreen(BYVAL color AS BYTE)
    ' Use function pointer for ultra-fast dispatch
    IF SVGADispatch.ClearScreen <> 0 THEN
        CALL DWORD SVGADispatch.ClearScreen USING ModeX_ClearScreen(color)
    END IF
END SUB

' =============================================================================
' Wait for vertical retrace (optimized assembly version)
' Parameters: None
' Returns: Nothing
' Note: Prevents screen tearing during animation - much faster than BASIC loops
' =============================================================================
SUB Svga_WaitVRetrace
    ' Ultra-fast assembly version of vertical retrace wait
    !MOV DX, &H3DA          ; VGA status port
    
    ' Wait for vertical retrace to end (if currently in retrace)
    WaitVRetraceEnd:
    !IN AL, DX              ; Read VGA status
    !TEST AL, 8             ; Test vertical retrace bit
    !JNZ WaitVRetraceEnd    ; Loop if still in retrace
    
    ' Wait for vertical retrace to start
    WaitVRetraceStart:
    !IN AL, DX              ; Read VGA status
    !TEST AL, 8             ; Test vertical retrace bit
    !JZ WaitVRetraceStart   ; Loop until retrace starts
END SUB

' =============================================================================
' Wait for horizontal retrace (optimized assembly version)
' Parameters: None
' Returns: Nothing
' Note: Much faster than BASIC loops for precise timing
' =============================================================================
SUB Svga_WaitHRetrace
    ' Ultra-fast assembly version of horizontal retrace wait
    !MOV DX, &H3DA          ; VGA status port
    
    ' Wait for horizontal retrace to start
    WaitHRetraceStart:
    !IN AL, DX              ; Read VGA status
    !TEST AL, 1             ; Test horizontal retrace bit
    !JZ WaitHRetraceStart   ; Loop until retrace starts
END SUB

' =============================================================================
' Set coordinate scaling factors (wrapper for Virtual_SetScale)
' Parameters:
'   XScale - X coordinate scaling factor (BYVAL)
'   YScale - Y coordinate scaling factor (BYVAL)
' Returns: Nothing
' Note: Affects all subsequent drawing operations
' =============================================================================
SUB Svga_SetScale(BYVAL xScale AS WORD, BYVAL yScale AS WORD)
    CALL Virtual_SetScale(xScale, yScale)
END SUB

' =============================================================================
' Get current scaling information (wrapper for Virtual_GetScale)
' Parameters:
'   ScaleType - Type of scale info to get: 0=XScale, 1=YScale, 2=XMax, 3=YMax (BYVAL)
'   Unused - Unused parameter for compatibility (BYVAL)
' Returns: Requested scale value
' =============================================================================
FUNCTION Svga_GetScale (BYVAL scaleType AS BYTE, BYVAL unused AS BYTE) AS WORD
    Svga_GetScale = Virtual_GetScale(scaleType, unused)
END FUNCTION

' =============================================================================
' Virtual Screen and Viewport Management Functions
' =============================================================================

' =============================================================================
' Set virtual screen dimensions (wrapper for Virtual_SetWindow)
' Parameters:
'   MaxX - Virtual screen width (BYVAL)
'   MaxY - Virtual screen height (BYVAL)
' Returns: Nothing
' Note: Sets up virtual coordinate system larger than physical screen
' =============================================================================
SUB Svga_SetWindow(BYVAL maxX AS WORD, BYVAL maxY AS WORD)
    CALL Virtual_SetWindow(maxX, maxY)
END SUB

' =============================================================================
' Set viewport/clipping region (wrapper for Virtual_SetViewport)
' Parameters:
'   X1, Y1 - Top-left corner of viewport (BYVAL)
'   X2, Y2 - Bottom-right corner of viewport (BYVAL)
' Returns: Nothing
' Note: All subsequent drawing operations will be clipped to this region
' =============================================================================
SUB Svga_SetView(BYVAL x1 AS WORD, BYVAL y1 AS WORD, BYVAL x2 AS WORD, BYVAL y2 AS WORD)
    CALL Virtual_SetViewport(x1, y1, x2, y2)
END SUB

' =============================================================================
' Library cleanup and finalization
' Parameters: None
' Returns: Nothing
' Note: Call this before program termination to clean up resources
' =============================================================================
SUB Svga_Cleanup
    ' Stop all animations first
    DIM I AS BYTE
    FOR I = 0 TO 7
        CALL DrawAni_StopAni(I)
        CALL DrawAni_FreeAni(I)
    NEXT I
    
    ' Close all icon libraries
    FOR I = 0 TO 3
        CALL DrawIcl_CloseIcoLib(I)
    NEXT I
    
    ' Cleanup sprite system
    CALL Sprite_CleanupSprites
    
    ' Cleanup scrolling system
    CALL Scroll_CleanupScroll
    
    ' Cleanup cursor system
    CALL Cursor_CleanupCursor
    
    ' Cleanup timer system (this will restore interrupts)
    CALL Timer_Cleanup
    
    ' Close any open EMS handles
    IF EMSMemoryContext.Handle <> 0 THEN
        CALL Memory_CloseEms(EMSMemoryContext.Handle)
    END IF
    
    ' Return to text mode
    CALL Vga_CloseVga
    
    ' Clear font data
    FontSystemContext.Data = ""
    FontSystemContext.LoadPath = ""
END SUB

' =============================================================================
' Additional dispatcher functions for optimized drawing operations
' =============================================================================

' =============================================================================
' Draw horizontal line (dispatcher)
' Parameters:
'   X1, X2 - Start and end X coordinates (BYVAL)
'   Y - Y coordinate (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' =============================================================================
SUB Svga_HLine(BYVAL x1 AS WORD, BYVAL x2 AS WORD, BYVAL y AS WORD, BYVAL color AS BYTE)
    DIM PhysicalX1 AS WORD, PhysicalY AS WORD, PhysicalX2 AS WORD, DummyY AS WORD
    
    ' Convert virtual coordinates to physical coordinates
    CALL Virtual_ToPhysical(x1, y, PhysicalX1, PhysicalY)
    CALL Virtual_ToPhysical(x2, y, PhysicalX2, DummyY)
    
    ' Check viewport clipping
    IF Virtual_IsVisible(x1, y) = 0 AND Virtual_IsVisible(x2, y) = 0 THEN EXIT SUB
    
    ' Use function pointer for ultra-fast dispatch
    IF SVGADispatch.HLine <> 0 THEN
        CALL DWORD SVGADispatch.HLine USING ModeX_HLine(PhysicalX1, PhysicalX2, PhysicalY, color)
    END IF
END SUB

' =============================================================================
' Draw vertical line (dispatcher)
' Parameters:
'   X - X coordinate (BYVAL)
'   Y1, Y2 - Start and end Y coordinates (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' =============================================================================
SUB Svga_VLine(BYVAL x AS WORD, BYVAL y1 AS WORD, BYVAL y2 AS WORD, BYVAL color AS BYTE)
    ' Use function pointer for ultra-fast dispatch
    IF SVGADispatch.VLine <> 0 THEN
        ' Note: ModeX_VLine has different parameter order (Y1, Y2, X, Color)
        SELECT CASE VESASystemContext.CurrentMode
            CASE %SVGA_MODEX
                CALL DWORD SVGADispatch.VLine USING ModeX_VLine(y1, y2, x, color)
            CASE ELSE
                CALL DWORD SVGADispatch.VLine USING Vga_VLine(x, y1, y2, color)
        END SELECT
    END IF
END SUB

' =============================================================================
' Draw filled rectangle (dispatcher)
' Parameters:
'   X1, Y1 - Top-left corner (BYVAL)
'   X2, Y2 - Bottom-right corner (BYVAL)
'   Color - Fill color (BYVAL)
' Returns: Nothing
' =============================================================================
SUB Svga_FillRect(BYVAL x1 AS WORD, BYVAL y1 AS WORD, BYVAL x2 AS WORD, BYVAL y2 AS WORD, BYVAL color AS BYTE)
    ' Use function pointer for ultra-fast dispatch
    IF SVGADispatch.FillRect <> 0 THEN
        CALL DWORD SVGADispatch.FillRect USING ModeX_FillRect(x1, y1, x2, y2, color)
    END IF
END SUB

' =============================================================================
' Draw rectangle outline (dispatcher)
' Parameters:
'   X1, Y1 - Top-left corner (BYVAL)
'   X2, Y2 - Bottom-right corner (BYVAL)
'   Color - Border color (BYVAL)
' Returns: Nothing
' =============================================================================
SUB Svga_DrawRect(BYVAL x1 AS WORD, BYVAL y1 AS WORD, BYVAL x2 AS WORD, BYVAL y2 AS WORD, BYVAL color AS BYTE)
    ' Use function pointer for ultra-fast dispatch
    IF SVGADispatch.DrawRect <> 0 THEN
        CALL DWORD SVGADispatch.DrawRect USING ModeX_DrawRect(x1, y1, x2, y2, color)
    END IF
END SUB

' =============================================================================
' Draw circle (dispatcher)
' Parameters:
'   CenterX, CenterY - Center coordinates (BYVAL)
'   Radius - Circle radius (BYVAL)
'   Color - Circle color (BYVAL)
' Returns: Nothing
' =============================================================================
SUB Svga_DrawCircle(BYVAL centerX AS WORD, BYVAL centerY AS WORD, BYVAL radius AS WORD, BYVAL color AS BYTE)
    ' Use function pointer for ultra-fast dispatch
    IF SVGADispatch.DrawCircle <> 0 THEN
        CALL DWORD SVGADispatch.DrawCircle USING ModeX_DrawCircle(centerX, centerY, radius, color)
    ELSE
        ' VESA doesn't have optimized circle - use generic implementation
        CALL Svga_DrawCircleGeneric(centerX, centerY, radius, color)
    END IF
END SUB

' =============================================================================
' Draw filled circle (dispatcher)
' Parameters:
'   CenterX, CenterY - Center coordinates (BYVAL)
'   Radius - Circle radius (BYVAL)
'   Color - Fill color (BYVAL)
' Returns: Nothing
' =============================================================================
SUB Svga_FillCircle(BYVAL centerX AS WORD, BYVAL centerY AS WORD, BYVAL radius AS WORD, BYVAL color AS BYTE)
    ' Use function pointer for ultra-fast dispatch
    IF SVGADispatch.FillCircle <> 0 THEN
        CALL DWORD SVGADispatch.FillCircle USING ModeX_FillCircle(centerX, centerY, radius, color)
    ELSE
        ' VESA doesn't have optimized filled circle - use generic implementation
        CALL Svga_FillCircleGeneric(centerX, centerY, radius, color)
    END IF
END SUB

' =============================================================================
' Generic circle drawing using PUTPIXEL (for modes without optimized circles)
' =============================================================================
SUB Svga_DrawCircleGeneric(BYVAL centerX AS WORD, BYVAL centerY AS WORD, BYVAL radius AS WORD, BYVAL color AS BYTE)
    DIM X AS INTEGER, Y AS INTEGER, DecisionParam AS INTEGER
    
    X = 0
    Y = radius
    DecisionParam = 1 - radius
    
    ' Draw initial points
    CALL Svga_PutPixel(centerX, centerY + radius, color)
    CALL Svga_PutPixel(centerX, centerY - radius, color)
    CALL Svga_PutPixel(centerX + radius, centerY, color)
    CALL Svga_PutPixel(centerX - radius, centerY, color)
    
    ' Draw circle using midpoint algorithm
    DO WHILE X < Y
        X = X + 1
        
        IF DecisionParam < 0 THEN
            DecisionParam = DecisionParam + 2 * X + 1
        ELSE
            Y = Y - 1
            DecisionParam = DecisionParam + 2 * (X - Y) + 1
        END IF
        
        ' Draw 8 symmetric points
        CALL Svga_PutPixel(centerX + X, centerY + Y, color)
        CALL Svga_PutPixel(centerX - X, centerY + Y, color)
        CALL Svga_PutPixel(centerX + X, centerY - Y, color)
        CALL Svga_PutPixel(centerX - X, centerY - Y, color)
        CALL Svga_PutPixel(centerX + Y, centerY + X, color)
        CALL Svga_PutPixel(centerX - Y, centerY + X, color)
        CALL Svga_PutPixel(centerX + Y, centerY - X, color)
        CALL Svga_PutPixel(centerX - Y, centerY - X, color)
    LOOP
END SUB

' =============================================================================
' Generic filled circle drawing using HLINE (for modes without optimized circles)
' =============================================================================
SUB Svga_FillCircleGeneric(BYVAL centerX AS WORD, BYVAL centerY AS WORD, BYVAL radius AS WORD, BYVAL color AS BYTE)
    DIM X AS INTEGER, Y AS INTEGER, DecisionParam AS INTEGER
    DIM PrevY AS INTEGER
    
    X = 0
    Y = radius
    DecisionParam = 1 - radius
    PrevY = Y
    
    ' Draw initial horizontal line
    CALL Svga_HLine(centerX - radius, centerX + radius, centerY, color)
    
    ' Fill circle using horizontal lines
    DO WHILE X < Y
        X = X + 1
        
        IF DecisionParam < 0 THEN
            DecisionParam = DecisionParam + 2 * X + 1
        ELSE
            ' Y changed, draw horizontal lines for previous Y
            IF Y <> PrevY THEN
                CALL Svga_HLine(centerX - X + 1, centerX + X - 1, centerY + PrevY, color)
                CALL Svga_HLine(centerX - X + 1, centerX + X - 1, centerY - PrevY, color)
                PrevY = Y
            END IF
            
            Y = Y - 1
            DecisionParam = DecisionParam + 2 * (X - Y) + 1
        END IF
        
        ' Draw horizontal lines for current positions
        CALL Svga_HLine(centerX - Y, centerX + Y, centerY + X, color)
        CALL Svga_HLine(centerX - Y, centerX + Y, centerY - X, color)
    LOOP
    
    ' Draw final lines if Y changed
    IF Y <> PrevY THEN
        CALL Svga_HLine(centerX - X, centerX + X, centerY + Y, color)
        CALL Svga_HLine(centerX - X, centerX + X, centerY - Y, color)
    END IF
END SUB