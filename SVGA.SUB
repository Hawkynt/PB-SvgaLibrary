' =============================================================================
' SVGA.SUB - Main SVGA Graphics Library
' =============================================================================
' Modular SVGA graphics library for Power BASIC 3.5
' Provides comprehensive graphics functions for VESA modes, image handling,
' font rendering, and memory management
' =============================================================================
' Author: Hawkynt
' License: LGPL 3.0
' =============================================================================

' Include all module files
$INCLUDE "TYPES.SUB"      ' Type definitions and global variables
$INCLUDE "VESA.SUB"       ' VESA graphics mode management
$INCLUDE "GRAPHICS.SUB"   ' Core drawing primitives
$INCLUDE "MEMORY.SUB"     ' EMS memory management
$INCLUDE "FONTS.SUB"      ' Font loading and text rendering
$INCLUDE "IMAGES.SUB"     ' Image file loading and display

' =============================================================================
' Initialize SVGA library
' Parameters: None
' Returns: Nothing
' Note: Call this before using any other library functions
' =============================================================================
SUB INITSVGA
    ' Initialize all context structures
    CALL InitializeSVGAContexts
    
    ' Set default values
    SVGAScreenContext.XRes = 0
    SVGAScreenContext.YRes = 0
    SVGAScreenContext.ColorDepth = 0
    SVGAScreenContext.WindowNumber = 0
    
    VESASystemContext.XRes = 0
    VESASystemContext.YRes = 0
    VESASystemContext.Window = 0
    VESASystemContext.OneLoadOnly = 0
    VESASystemContext.TransparentColor = 0
    VESASystemContext.BMPMode = 0
    
    WindowSystemContext.Current = 0
    
    FontSystemContext.Data = ""
    FontSystemContext.CharWidth = 8
    FontSystemContext.CharHeight = 8
    FontSystemContext.LoadPath = ""
    
    ScaleSystemContext.XScale = 1
    ScaleSystemContext.YScale = 1
    ScaleSystemContext.KScale = 1
END SUB

' =============================================================================
' Core pixel manipulation functions
' =============================================================================

' =============================================================================
' Set a single pixel on screen
' Parameters:
'   X, Y - Pixel coordinates (BYVAL)
'   Color - Pixel color value (BYVAL)
' Returns: Nothing
' Note: This is the core pixel-setting function used by all drawing operations
' =============================================================================
SUB PUTPIXEL(BYVAL X AS WORD, BYVAL Y AS WORD, BYVAL Color AS WORD)
    ' Apply coordinate scaling if active
    IF ScaleSystemContext.XScale <> 1 OR ScaleSystemContext.YScale <> 1 THEN
        X = X * ScaleSystemContext.XScale
        Y = Y * ScaleSystemContext.YScale
    END IF
    
    ' Apply coordinate offset adjustments
    X = X - VESASystemContext.XDecrease
    Y = Y - VESASystemContext.YDecrease
    
    ' Clip to viewport if active
    IF WindowSystemContext.Current > 0 THEN
        IF X < WindowSystemContext.X1 OR X > WindowSystemContext.X2 THEN EXIT SUB
        IF Y < WindowSystemContext.Y1 OR Y > WindowSystemContext.Y2 THEN EXIT SUB
    END IF
    
    ' Calculate pixel address and set pixel using VESA banking if needed
    DIM ByteOffset AS LONG, WindowNumber AS WORD, PixelOffset AS WORD
    
    IF SVGAScreenContext.ColorDepth = 8 THEN
        ' 8-bit color mode
        ByteOffset = Y * SVGAScreenContext.BytesPerLine + X
        WindowNumber = ByteOffset \ 65536  ' 64K window size
        PixelOffset = ByteOffset MOD 65536
        
        ' Switch VESA window if needed
        IF WindowNumber <> SVGAScreenContext.WindowNumber THEN
            CALL SETVESAWINDOW(WindowNumber)
            SVGAScreenContext.WindowNumber = WindowNumber
        END IF
        
        ' Set pixel using direct memory access
        DEF SEG = &HA000
        POKE PixelOffset, Color
        DEF SEG
    ELSE
        ' Other color modes - simplified implementation
        DEF SEG = &HA000
        POKE Y * 320 + X, Color  ' Assume 320-pixel width for compatibility
        DEF SEG
    END IF
END SUB

' =============================================================================
' Get a single pixel color from screen
' Parameters:
'   X, Y - Pixel coordinates (BYVAL)
' Returns: Pixel color value
' =============================================================================
FUNCTION GETPIXEL (BYVAL X AS WORD, BYVAL Y AS WORD) AS BYTE
    ' Apply coordinate transformations
    IF ScaleSystemContext.XScale <> 1 OR ScaleSystemContext.YScale <> 1 THEN
        X = X * ScaleSystemContext.XScale
        Y = Y * ScaleSystemContext.YScale
    END IF
    
    X = X - VESASystemContext.XDecrease
    Y = Y - VESASystemContext.YDecrease
    
    ' Calculate pixel address and get pixel value
    DIM ByteOffset AS LONG, WindowNumber AS WORD, PixelOffset AS WORD
    
    IF SVGAScreenContext.ColorDepth = 8 THEN
        ByteOffset = Y * SVGAScreenContext.BytesPerLine + X
        WindowNumber = ByteOffset \ 65536
        PixelOffset = ByteOffset MOD 65536
        
        ' Switch VESA window if needed
        IF WindowNumber <> SVGAScreenContext.WindowNumber THEN
            CALL SETVESAWINDOW(WindowNumber)
            SVGAScreenContext.WindowNumber = WindowNumber
        END IF
        
        ' Get pixel value
        DEF SEG = &HA000
        GETPIXEL = PEEK(PixelOffset)
        DEF SEG
    ELSE
        ' Fallback for other modes
        DEF SEG = &HA000
        GETPIXEL = PEEK(Y * 320 + X)
        DEF SEG
    END IF
END FUNCTION

' =============================================================================
' Draw a line between two points
' Parameters:
'   X1, Y1 - Starting point coordinates (BYVAL)
'   X2, Y2 - Ending point coordinates (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' Note: Uses Bresenham's line algorithm for smooth lines
' =============================================================================
SUB LINEDRAW(BYVAL X1 AS WORD, BYVAL Y1 AS WORD, BYVAL X2 AS WORD, BYVAL Y2 AS WORD, BYVAL Color AS LONG)
    DIM DeltaX AS INTEGER, DeltaY AS INTEGER, StepX AS INTEGER, StepY AS INTEGER
    DIM ErrorTerm AS INTEGER, CurrentX AS WORD, CurrentY AS WORD
    
    ' Calculate deltas and step directions
    DeltaX = ABS(X2 - X1)
    DeltaY = ABS(Y2 - Y1)
    
    IF X1 < X2 THEN StepX = 1 ELSE StepX = -1
    IF Y1 < Y2 THEN StepY = 1 ELSE StepY = -1
    
    ' Initialize error term
    ErrorTerm = DeltaX - DeltaY
    
    ' Set starting position
    CurrentX = X1
    CurrentY = Y1
    
    ' Draw line using Bresenham's algorithm
    DO
        CALL PUTPIXEL(CurrentX, CurrentY, Color)
        
        ' Check if we've reached the end point
        IF CurrentX = X2 AND CurrentY = Y2 THEN EXIT DO
        
        ' Calculate next point
        DIM Error2 AS INTEGER
        Error2 = ErrorTerm * 2
        
        IF Error2 > -DeltaY THEN
            ErrorTerm = ErrorTerm - DeltaY
            CurrentX = CurrentX + StepX
        END IF
        
        IF Error2 < DeltaX THEN
            ErrorTerm = ErrorTerm + DeltaX
            CurrentY = CurrentY + StepY
        END IF
    LOOP
END SUB

' =============================================================================
' Clear entire screen to specified color
' Parameters:
'   Color - Fill color (BYVAL, optional - defaults to 0/black)
' Returns: Nothing
' =============================================================================
SUB CLEARSCREEN(BYVAL Color AS BYTE)
    DIM X AS WORD, Y AS WORD
    
    ' Fill screen pixel by pixel
    FOR Y = 0 TO SVGAScreenContext.YRes - 1
        FOR X = 0 TO SVGAScreenContext.XRes - 1
            CALL PUTPIXEL(X, Y, Color)
        NEXT X
    NEXT Y
END SUB

' =============================================================================
' Wait for vertical retrace
' Parameters: None
' Returns: Nothing
' Note: Prevents screen tearing during animation
' =============================================================================
SUB WAITVRETRACE
    ' Wait for vertical retrace start
    DO WHILE (INP(&H3DA) AND 8) <> 0 : LOOP  ' Wait for retrace to end
    DO WHILE (INP(&H3DA) AND 8) = 0 : LOOP  ' Wait for retrace to start
END SUB

' =============================================================================
' Wait for horizontal retrace
' Parameters: None
' Returns: Nothing
' =============================================================================
SUB WAITHRETRACE
    ' Wait for horizontal retrace
    DO WHILE (INP(&H3DA) AND 1) = 0 : LOOP
END SUB

' =============================================================================
' Set coordinate scaling factors
' Parameters:
'   XScale - X coordinate scaling factor (BYVAL)
'   YScale - Y coordinate scaling factor (BYVAL)
' Returns: Nothing
' Note: Affects all subsequent drawing operations
' =============================================================================
SUB SETSCALE(BYVAL XScale AS WORD, BYVAL YScale AS WORD)
    ScaleSystemContext.XScale = XScale
    ScaleSystemContext.YScale = YScale
    
    ' Update maximum scaled coordinates
    ScaleSystemContext.XScaleMax = SVGAScreenContext.XRes \ XScale
    ScaleSystemContext.YScaleMax = SVGAScreenContext.YRes \ YScale
END SUB

' =============================================================================
' Get current scaling information
' Parameters:
'   ScaleType - Type of scale info to get: 0=XScale, 1=YScale, 2=XMax, 3=YMax (BYVAL)
'   Unused - Unused parameter for compatibility (BYVAL)
' Returns: Requested scale value
' =============================================================================
FUNCTION GETSCALE (BYVAL ScaleType AS BYTE, BYVAL Unused AS BYTE) AS WORD
    SELECT CASE ScaleType
        CASE 0: GETSCALE = ScaleSystemContext.XScale
        CASE 1: GETSCALE = ScaleSystemContext.YScale
        CASE 2: GETSCALE = ScaleSystemContext.XScaleMax
        CASE 3: GETSCALE = ScaleSystemContext.YScaleMax
        CASE ELSE: GETSCALE = 1
    END SELECT
END FUNCTION

' =============================================================================
' Library cleanup and finalization
' Parameters: None
' Returns: Nothing
' Note: Call this before program termination to clean up resources
' =============================================================================
SUB CLEANUPSVGA
    ' Close any open EMS handles
    IF EMSMemoryContext.Handle <> 0 THEN
        CALL CLOSEEMS(EMSMemoryContext.Handle)
    END IF
    
    ' Return to text mode
    CALL CLOSEVGA
    
    ' Clear font data
    FontSystemContext.Data = ""
    FontSystemContext.LoadPath = ""
END SUB