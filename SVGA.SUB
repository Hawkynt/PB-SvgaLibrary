SHARED XSCREEN,YSCREEN,FONT$,GRAN%,VESAX%,VESAY%,VESAOFF&,ANFX%,ANFY%,ENDX%,ENDY%
SHARED PFRAME%,VESAEMS,VESAHANDLE,OLDEMSPAGE%,OLDEMSHANDLE%,VESAXDECR,VESAYDECR,VESATRANS%,BPP%
SHARED VESAONEONLY,BMPX1,BMPY1,BMPX2,BMPY2,VESABMP,CHARX,CHARY
SHARED BMPOFF,BMPHANDLE,BMPXSCREEN,BMPYSCREEN,BMPCSCREEN,BMPBPP%,BMPVGATX#,BMPVGATY#

DIM VESAONELOAD AS SHARED BYTE

DIM VESAWINDOW AS SHARED WORD
DIM CSCREEN AS SHARED WORD
DIM BPLINE AS SHARED WORD
DIM MSCREEN AS SHARED WORD
DIM CWIN AS SHARED BYTE
CWIN=0

DIM XSCALE AS SHARED WORD,YSCALE AS SHARED WORD,KSCALE AS SHARED WORD
DIM XSCMAX AS SHARED WORD,YSCMAX AS SHARED WORD


LOADDISK:
DATA "010101010101010101010101hghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghg040404040404040404040404"
DATA "01010101010101010101hg01hghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghg04040404040404040404hg04"
DATA "010101010101010101010101hghg15151515hghghghghghg151515hghghghghg1515hghghg1515151515hghghg151515151515hg1515hghghg1515hghghg15151515hghghghg040404040404040404040404"
DATA "010101010101010101010101hghghg1515hghghghghghg1515hg1515hghghg15151515hghghg1515hg1515hghghghg1515hghghg151515hghg1515hghg1515hghg1515hghghg040404040404040404040404"
DATA "010101010101010101010101hghghg1515hghghghghg1515hghghg1515hg1515hghg1515hghg1515hghg1515hghghg1515hghghg15151515hg1515hg1515hghghghghghghghg040404040404040404040404"
DATA "010101010101010101010101hghghg1515hghghghghg1515hghghg1515hg1515hghg1515hghg1515hghg1515hghghg1515hghghg1515hg15151515hg1515hghghghghghghghg040404040404040404040404"
DATA "010101010101010101010101hghghg1515hghghg15hg1515hghghg1515hg151515151515hghg1515hghg1515hghghg1515hghghg1515hghg151515hg1515hghg151515hghghg040404040404040404040404"
DATA "010101010101010101010101hghghg1515hghg1515hghg1515hg1515hghg1515hghg1515hghg1515hg1515hghghghg1515hghghg1515hghghg1515hg1515hghghg1515hghghg040404040404040404040404"
DATA "010101010101010101010101hghg15151515151515hghghg151515hghghg1515hghg1515hg1515151515hghghg151515151515hg1515hghghg1515hghg151515151515hghghg040404040404040404040404"
DATA "010107070707070701010101hghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghg040407070707070704040404"
DATA "010107010707070701010101hghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghg040407040707070704040404"
DATA "010107010707070701010101hghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghghg040407040707070704040404"
DATA "99"

SUB BAR (TX1, TY1, TX2, TY2, c AS LONG, C2 AS LONG)
 X1=TX1
 X2=TX2
 Y1=TY1
  Y2=TY2
 IF Y2 < Y1 THEN SWAP Y1, Y2
 IF X2 < X1 THEN SWAP X1, X2
 FOR T = Y1 TO Y2
  CALL LINEDRAW(X1, T, X2, T, C2)
 NEXT
 CALL LINEDRAW(X1, Y1, X2, Y1, c)
 CALL LINEDRAW(X1, Y1, X1, Y2, c)
 CALL LINEDRAW(X2, Y2, X1, Y2, c)
 CALL LINEDRAW(X2, Y2, X2, Y1, c)
END SUB

SUB BAR3D (X1, Y1, X2, Y2, TIEF, c AS LONG, C2 AS LONG)
 IF Y2 < Y1 THEN SWAP Y1, Y2
 IF X2 < X1 THEN SWAP X1, X2
 IF C2 > 0 THEN
  FOR T = Y1 TO Y2
   CALL LINEDRAW(X1, T, X2, T, C2)
  NEXT
 END IF
 CALL LINEDRAW(X1, Y1, X2, Y1, c)
 CALL LINEDRAW(X1, Y1, X1, Y2, c)
 CALL LINEDRAW(X2, Y2, X1, Y2, c)
 CALL LINEDRAW(X2, Y2, X2, Y1, c)
 CALL LINEDRAW(X1, Y1, X1 + TIEF, Y1 - TIEF, c)
 CALL LINEDRAW(X2, Y1, X2 + TIEF, Y1 - TIEF, c)
 CALL LINEDRAW(X1 + TIEF, Y1 - TIEF, X2 + TIEF, Y1 - TIEF, c)
 CALL LINEDRAW(X2, Y2, X2 + TIEF, Y2 - TIEF, c)
 CALL LINEDRAW(X2 + TIEF, Y1 - TIEF, X2 + TIEF, Y2 - TIEF, c)
END SUB

SUB BOX (X1, Y1, X2, Y2, c AS LONG)
 CALL BAR(X1, Y1, X2, Y2, c, c)
END SUB

SUB CIRCLEDRAW (XM, YM, XR, YR, WA, WE, c AS LONG, F)
 PI = 4 * ATN(1)
 IF (XR + YR) / 2 = 0 THEN NE = 1 ELSE NE = 1 / ((XR + YR) / 64) '64
 IF WE < WA THEN NE = -NE
 X =INT( XM + XR * COS(WA * PI / 180))
 Y =INT( YM + YR * SIN(WA * PI / 180))
 IF F = 0 THEN
  FOR W = WA TO WE STEP NE
   OX = X
   OY = Y
   X =INT( XM + XR * COS(W * PI / 180))
   Y =INT( YM + YR * SIN(W * PI / 180))
   CALL LINEDRAW(OX, OY, X, Y, c)
  NEXT
 ELSE
  YT = YR
  XT = XR
  DO
   YT = YT - .5
   IF YT < 0 THEN YT = 0
   XT = XT - .5
   IF XT < 0 THEN XT = 0
   CALL CIRCLEDRAW(XM, YM, XT, YT, WA, WE, c, 0)
  LOOP UNTIL XT = 1 AND YT = 1
 END IF
END SUB

SUB CLOSEVGA
 REG 1, &H3
 CALL INTERRUPT &H10
END SUB

FUNCTION GETCOL(R,G,B)
 DIM PAL(255,2)
 OUT &H3C7,0
 FOR T=0 TO 255
  PAL(T,0)=INP(&H3C9)
  PAL(T,1)=INP(&H3C9)
  PAL(T,2)=INP(&H3C9)
 NEXT
 DO
  FOR T=0 TO 255
   IF ((PAL(T,0)+V<=R) AND (PAL(T,0)-V>=R)) AND ((PAL(T,1)+V<=G) AND (PAL(T,1)-V>=G)) AND ((PAL(T,2)+V<=B) AND (PAL(T,2)-V>=B)) THEN
    GETCOL=T
    EXIT FUNCTION
   END IF
  NEXT
  V=V+1
 LOOP UNTIL V=255
END FUNCTION

SUB CLEARSCREEN
 CALL CLOSEVGA
 CALL SETVGA(MSCREEN)
END SUB

SUB COPYBOX (X1, Y1, X2, Y2, X3, Y3, FLAG)
 IF X2 < X1 THEN SWAP X1, X2
 IF Y2 < Y1 THEN SWAP Y1, Y2
 FOR YT = Y1 TO Y2
  FOR XT = X1 TO X2
   c = GETPIXEL(XT, YT)
   IF FLAG <> 0 THEN c = 255 - c
   CALL PUTPIXEL(XT - X1 + X3, YT - Y1 + Y3, c)
  NEXT
 NEXT
END SUB

SUB DRAWPOLY (T(), C AS LONG)
 Y=LBOUND(T(1))
 Z=UBOUND(T(1))
 FOR G = Y+1 TO Z
  CALL LINEDRAW(T(G - 1, 0), T(G - 1, 1), T(G, 0), T(G, 1), c)
 NEXT
 CALL LINEDRAW(T(Y, 0), T(Y, 1), T(Z, 0), T(Z, 1), C)
END SUB

SUB FRAME (X1, Y1, X2, Y2, c AS LONG)
 CALL LINEDRAW(X1, Y1, X2, Y1 ,C)
 CALL LINEDRAW(X1, Y1, X1, Y2 ,C)
 CALL LINEDRAW(X2, Y2, X2, Y1 ,C)
 CALL LINEDRAW(X2, Y2, X1, Y2 ,C)
END SUB

FUNCTION GETANINUM (FILE$)
 Z=FREEFILE
 OPEN "B", #Z, FILE$
  SEEK Z, &H1C
  GET$ Z,1,T$
  GETANINUM = ASC(T$)
 CLOSE Z
END FUNCTION

FUNCTION GETANISPEED (FILE$)
 Z=FREEFILE
 OPEN "B", #Z, FILE$
  SEEK Z, &H40
  GET$ Z,1,T$
  GETANISPEED = ASC(T$)
 CLOSE Z
END FUNCTION

SUB GETBMPPAL (FILE$, PAL(), BITS)
 IF BITS = 0 THEN BITS = 6
 W = 2 ^ BITS - 1
 Z=FREEFILE
 OPEN "B",#Z,FILE$
  SEEK Z, &H1C
  GET$ Z,2,T$
  C=2^(ASC(LEFT$(T$,1))+256*ASC(RIGHT$(T$,1)))
  SEEK Z, &H36
  FOR T = 0 TO C-1
   GET$ Z,1,B$
   GET$ Z,1,G$
   GET$ Z,1,R$
   GET$ Z,1,I$
   PAL(T, 0) = ASC(R$) * W / 255
   PAL(T, 1) = ASC(G$) * W / 255
   PAL(T, 2) = ASC(B$) * W / 255
  NEXT
 CLOSE Z
END SUB

SUB GETBMPSPRITE (T$, S$)
 Z=FREEFILE
 OPEN "B",#Z,T$
  SEEK Z, &HA
  GET$ Z,4,A$
  OFFDATA = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  SEEK Z, &H12
  GET$ Z,4,A$
  XMAX = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  GET$ Z,4,A$
  YMAX = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  SEEK Z, &H1C
  GET$ Z,2,T$
  C=2^(ASC(LEFT$(T$,1))+256*ASC(RIGHT$(T$,1)))
  SEEK Z, OFFDATA
  SELECT CASE C
   CASE 256
    DIM PIX%(XMAX,YMAX)
    Y=YMAX-1
    DO
     GET$ Z,XMAX,C$
     FOR X = 0 TO XMAX - 1
      PIX%(X, Y) = ASC(MID$(c$, X + 1, 1))
     NEXT
     Y=Y-1
    LOOP UNTIL Y<0
   CASE 16
    DIM PIX%(XMAX+4,YMAX)
    Y=YMAX-1
    DO
     T=XMAX/2+2
     IF T<>INT(T) THEN T=INT(T)+1
     GET$ Z,T,C$
     FOR X = 0 TO T-1
      PIX%(X*2+0, Y) = ASC(MID$(c$, X + 1, 1)) MOD 16
      PIX%(X*2+1, Y) = INT(ASC(MID$(c$, X + 1, 1)) /16)
     NEXT
     Y=Y-1
    LOOP UNTIL Y<0
  END SELECT
 CLOSE Z
 S$ = CHR$(XMAX - 1) + CHR$(YMAX - 1)
 FOR Y = 0 TO YMAX - 1
  FOR X = 0 TO XMAX - 1
   S$ = S$ + CHR$(PIX%(X, Y))
  NEXT
 NEXT
END SUB

FUNCTION GETBOX (BYVAL X1 AS WORD,BYVAL Y1 AS WORD,BYVAL X2 AS WORD,BYVAL Y2 AS WORD) AS STRING
 DIM X AS BYTE,Y AS BYTE,C AS LONG,T AS STRING,D AS BYTE
 X=X2-X1
 Y=Y2-Y1
 T=STRING$(X*Y+2,0)
 MID$(T,1,2)=CHR$(X)+CHR$(Y)
 DIM OFFS AS WORD,SEGM AS WORD
 OFFS=STRPTR(T)
 SEGM=STRSEG(T)
 !PUSH ES
 !PUSH DI
 !MOV DI,OFFS
 !MOV ES,SEGM
 !MOV CL,ES:[DI]
 !INC DI
 !MOV CH,ES:[DI]
 !MOV X,0
 !MOV Y,0
 SHRSPRLOOP1:
 !MOV OFFS,DI
 !POP DI
 !POP ES
 !PUSH CX
 D=GETPIXEL(X1+X,Y1+Y)
 !JMP SHRSPRLOOP3
 SHRSPRLOOP2:
 !JMP SHRSPRLOOP1
 SHRSPRLOOP3:
 !POP CX
 !PUSH ES
 !PUSH DI
 !MOV ES,SEGM
 !MOV DI,OFFS
 !INC DI
 !MOV AL,D
 !MOV ES:[DI],AL
 !INC X
 !CMP X,CL
 !JNE SHRSPRLOOP2
 !MOV X,0
 !INC Y
 !CMP Y,CH
 !JNE SHRSPRLOOP2
 !POP DI
 !POP ES
 GETBOX=T
END FUNCTION

SUB GETPCXPAL (N$, PAL(), BITS)
 IF BITS = 0 THEN BITS = 6
 Z=FREEFILE
 OPEN "B",#Z,N$
  SEEK Z, LOF(Z) - 768
  W = 2 ^ BITS - 1
  FOR T = 0 TO 255
   GET$ Z,1,R$
   GET$ Z,1,G$
   GET$ Z,1,B$
   PAL(T, 0) = ASC(R$) * W / 255
   PAL(T, 1) = ASC(G$) * W / 255
   PAL(T, 2) = ASC(B$) * W / 255
  NEXT
 CLOSE Z
END SUB

FUNCTION GETPIXEL (BYVAL X AS WORD,BYVAL Y AS WORD) AS BYTE
 IF X>XSCMAX OR Y>YSCMAX THEN EXIT FUNCTION
 DIM XR AS WORD,YR AS WORD

 !PUSH DI
 !PUSH SI

 !MOV CX,KSCALE          ;KONSTANTEN
 !MOV DI,XSCALE          ; -||-
 !MOV SI,YSCALE          ; -||-

 !MOV AX,X               ;X*XSCALE/K
 !MUL DI
 !DIV CX
 !MOV XR,AX              ;XREAL 1.
 !MOV AX,Y
 !MUL SI
 !DIV CX
 !MOV YR,AX
 !POP SI
 !POP DI

 C& = -1
 CALL PIXEL(XR+0, YR+0, C&)
 IF C&=-1 THEN C&=0
 GETPIXEL = C&
END FUNCTION

FUNCTION GETSCALE (T, F)
 IF T = 13 THEN
  GRAN% = 0
  XSCR = 320
  YSCR = 200
  CSCR = 256
 ELSE
  T$ = STRING$(512, 219)
  SEGMENT = STRSEG(T$)
  OFFSET = STRPTR(T$)
  REG 1, &H4F01
  REG 3, T
  REG 9, SEGMENT
  REG 6, OFFSET
  CALL INTERRUPT &H10
  DEF SEG = SEGMENT
  BPLINE = PEEK(OFFSET + &H10) + 256 * PEEK(OFFSET + &H11)
  GRAN% = PEEK(OFFSET + 4) + 256 * PEEK(OFFSET + 5)
  XSCR = PEEK(OFFSET + &H12) + 256 * PEEK(OFFSET + &H13)
  YSCR = PEEK(OFFSET + &H14) + 256 * PEEK(OFFSET + &H15)
  BPPIX = ASC(MID$(T$, &H1A, 1))
  CSCR = 2 ^ ASC(MID$(T$, &H1A, 1))
  DEF SEG
 END IF
 SELECT CASE F
  CASE 0
   GETSCALE = XSCR
  CASE 1
   GETSCALE = YSCR
  CASE 2
   GETSCALE = CSCR
  CASE 3
   GETSCALE = T
  CASE 4
   GETSCALE = GRAN%
  CASE 5
   GETSCALE = BPLINE
  CASE 6
   GETSCALE = BPPIX
 END SELECT
END FUNCTION

FUNCTION GETVESAMODE (X, Y, c)
 T$ = STRING$(256, 219)
 T2$ = STRING$(256, 219)
 REG 1, &H4F00
 REG 6, STRPTR(T$)
 REG 9, STRSEG(T$)
 CALL INTERRUPT &H10
 FAROFF = ASC(MID$(T$, 15, 1)) + 256 * ASC(MID$(T$, 16, 1))
 FARSEG = ASC(MID$(T$, 17, 1)) + 256 * ASC(MID$(T$, 18, 1))
 DEF SEG = FARSEG
 DO
  U = PEEK(FAROFF + Z) + 256 * PEEK(FAROFF + Z + 1)
  REG 1, &H4F01
  REG 3, U
  REG 9, STRSEG(T2$)
  REG 6, STRPTR(T2$)
  CALL INTERRUPT &H10
  XMAX = ASC(MID$(T2$, &H13, 1)) + 256 * ASC(MID$(T2$, &H14, 1))
  YMAX = ASC(MID$(T2$, &H15, 1)) + 256 * ASC(MID$(T2$, &H16, 1))
  CMAX = 2 ^ ASC(MID$(T2$, &H1A, 1))
  IF X = XMAX AND Y = YMAX AND C = CMAX THEN GETVESAMODE = U: EXIT FUNCTION
  Z = Z + 2
  TESTX = PEEK(FAROFF + Z) + 256 * PEEK(FAROFF + Z + 1)
 LOOP UNTIL TESTX = 65535
 GETVESAMODE = -1
END FUNCTION

SUB INITFONT (A$, FLAG)
 FONT$ = ""
 IF FLAG = 1 THEN
  CLS
  PRINT "LOAD " + CHR$(34) + UCASE$(A$) + CHR$(34) + ",8,1"
  PRINT "LOADING FROM $2000 TO $3000"
 ELSEIF FLAG = 2 THEN
  CALL LOADING(0)
 END IF
 Z=FREEFILE

 OPEN "I",#Z,A$
  FOR T = 0 TO 255
   INPUT #Z, A$
   T1 = INSTR(A$, " ")
   T2 = INSTR(T1 + 1, A$, " ")
   T3 = INSTR(T2 + 1, A$, " ")
   T4 = INSTR(T3 + 1, A$, " ")
   T5 = INSTR(T4 + 1, A$, " ")
   T6 = INSTR(T5 + 1, A$, " ")
   T7 = INSTR(T6 + 1, A$, " ")
   T8 = LEN(A$)
   T1$ = MID$(A$, 1, T1)
   T2$ = MID$(A$, T1 + 1, T2 - T1)
   T3$ = MID$(A$, T2 + 1, T3 - T2)
   T4$ = MID$(A$, T3 + 1, T4 - T3)
   T5$ = MID$(A$, T4 + 1, T5 - T4)
   T6$ = MID$(A$, T5 + 1, T6 - T5)
   T7$ = MID$(A$, T6 + 1, T7 - T6)
   T8$ = RIGHT$(A$, T8 - T7)
   FONT$ = FONT$ + CHR$(VAL(T1$)) + CHR$(VAL(T2$)) + CHR$(VAL(T3$)) + CHR$(VAL(T4$)) + CHR$(VAL(T5$)) + CHR$(VAL(T6$)) + CHR$(VAL(T7$)) + CHR$(VAL(T8$))
   IF FLAG = 1 THEN
    PRINT CHR$(T)
    LOCATE 3, 1
   END IF
   IF EOF(Z) THEN
    EXIT FOR
   END IF
  NEXT
 CLOSE Z
 IF FLAG = 1 THEN
  PRINT "READY."
 ELSEIF FLAG = 2 THEN
  CALL LOADING(1)
 END IF
 CHARX=8
 CHARY=8
END SUB

SUB LINEDRAW(x1S, y1S, x2S, y2S, C AS LONG)
         LOCAL s1%, s2%, s3%, s4%,X%,Y%,X1%,Y1%,X2%,Y2%
         X1%=X1S
         Y1%=Y1S
         X2%=X2S
         Y2%=Y2S
         ! mov  ax, x2%         ;' Differenz x2% - x1% nach ax
         ! sub  ax, x1%
         ! jns  IRLINECPU1
         ! neg  ax              ; Vorzeichentausch
IRLINECPU1:
         ! mov  bx, y2%         ; Differenz von y2% - y1% nach bx
         ! sub  bx, y1%
         ! jns  IRLINECPU2
         ! neg  bx              ; Vorzeichentausch
IRLINECPU2:
         ! cmp  ax, bx          ; Steigung <= 1 ?
         ! jge  IRLINECPU3A         ; Ja
         ! jmp  IRLINECPU20         ; Nein
IRLINECPU3A:
         ! mov  cx, x1%         ; Ist x1% <= x2% ?
         ! cmp  cx, x2%
         ! jg   IRLINECPU4
         ! mov  cx, 1           ; X steigt
         ! jmp  IRLINECPU5
IRLINECPU4:
         ! mov  cx, -1          ; X f„llt
IRLINECPU5:
         ! mov  dx, y1%         ; ist y1% <= y2%
         ! cmp  dx, y2%
         ! jg   IRLINECPU6
         ! mov  dx, 1           ; Y steigt
         ! jmp  IRLINECPU7
IRLINECPU6:
         ! mov  dx, -1          ; Y f„llt
IRLINECPU7:
         ! mov  s1%, cx         ; Steigung auf dem Stack speichern
         ! mov  s2%, dx
         ! add  bx, bx          ; Steigung berechnen
         ! mov  s3%, bx
         ! sub  bx, ax
         ! mov  cx, bx
         ! sub  cx, ax
         ! mov  s4%, cx
         ! mov  cx, x1%
         ! mov  dx, y1%
         ! call IRLINECPU9A
IRLINECPU8:
         ! cmp  cx, x2%         ; Weitere Punkte?
         ! jz   IRLINECPU3
         ! add  cx, s1%         ; X-Koordinate erh”hen
         ! or   bx, bx          ; Entscheiden, ob Y-Koordinate erh”ht
         ! jns  IRLINECPU10         ; wird
         ! add  bx, s3%
         ! jmp  IRLINECPU11
IRLINECPU10:
         ! add  bx, s4%         ; N„chsten Punkt ausgeben
         ! add  dx, s2%
IRLINECPU11:
         ! call IRLINECPU9A
         ! jmp IRLINECPU8
IRLINECPU20:

';----------------------------------------------------------
'; Dieser Teil wird durchlaufen, wenn die Steigung > 1 ist
';----------------------------------------------------------

         ! mov  cx, y1%         ; Steigung ist > 1
         ! cmp  cx, y2%         ; Ist y1% <= y2% ?
         ! jg   IRLINECPU12
         ! mov  cx,1            ; Y steigt
         ! jmp  IRLINECPU13
IRLINECPU12:
         ! mov  cx, -1          ; Y f„llt
IRLINECPU13:
         ! mov  dx, x1%         ; ist x1% <= x2% ?
         ! cmp  dx, x2%
         ! jg   IRLINECPU14
         ! mov  dx, 1           ; X steigt
         ! jmp  IRLINECPU15
IRLINECPU14:
         ! mov  dx, -1          ; X f„llt
IRLINECPU15:
         ! mov  s1%, cx         ; Steigung auf dem Stack speichern
         ! mov  s2%, dx
         ! add  ax, ax          ; Steigung berechnen
         ! mov  s3%, ax
         ! sub  ax, bx
         ! mov  cx, ax
         ! sub  cx, bx
         ! mov  s4%, cx
         ! mov  bx, ax
         ! mov  cx, x1%
         ! mov  dx, y1%
         ! call IRLINECPU9A
IRLINECPU16:
         ! cmp  dx, y2%         ; Weitere Punkte ausgeben?
         ! jz   IRLINECPU3
         ! add  dx, s1%
         ! or   bx, bx
         ! jns  IRLINECPU18
         ! add  bx, s3%
         ! jmp  IRLINECPU19
IRLINECPU18:
         ! add bx, s4%
         ! add cx, s2%
IRLINECPU19:
         ! call IRLINECPU9A
         ! jmp  IRLINECPU16
IRLINECPU3:
         ! jmp IRLINECPU9B
IRLINECPU9A:
         !PUSH AX
         !PUSH BX
         !PUSH CX
         !PUSH DX

         !MOV X%,CX
         !MOV Y%,DX

         CALL PUTPIXEL(BYVAL X%,BYVAL Y%,C)

         !POP DX
         !POP CX
         !POP BX
         !POP AX

         ! retn
IRLINECPU9B:
END SUB

SUB LOADANISPRITE (FILE$, TP$, A)
 N = GETANINUM(FILE$)
 DIM FRAMES$(N)
 DIM TEMP(32, 32)
 ZI=FREEFILE
 OPEN "B", #ZI, FILE$
  FOR T = 1 TO 242
   SEEK ZI, T
   GET$ ZI,4,A$
   IF A$ = "icon" THEN EXIT FOR
  NEXT
  GET$ ZI,130,A$
  FOR T = 1 TO A - 1
   GET$ ZI,774,T$
  NEXT
  GET$ ZI,512,T$
  Z = 1
  Y=31
  DO
   FOR X = 0 TO 15
    A$ = MID$(T$, Z, 1) + CHR$(0)
    C2 = INT(ASC(A$) / 16)
    C1 = ASC(A$) - 16 * C2
    TEMP(X * 2, Y) = C2
    TEMP(X * 2 + 1, Y) = C1
    Z = Z + 1
   NEXT
   Y=Y-1
  LOOP UNTIL Y<0
  TP$=CHR$(31)+CHR$(31)
  FOR Y = 0 TO 31
   FOR X = 0 TO 31
    TP$ = TP$ + CHR$(TEMP(X, Y))
   NEXT
  NEXT
 CLOSE ZI
END SUB

SUB LOADICONPAL (T$, PAL())
 Z=FREEFILE
 OPEN "b", #Z, T$
  SEEK Z, 6
  GET$ Z,1,XA$
  GET$ Z,1,YA$
  GET$ Z,1,RLE$
  RLE = ASC(RLE$)
  IF RLE <> 16 THEN RLE = 256
  SEEK Z, 62
  FOR T = 0 TO RLE - 1
   GET$ Z,1,R$
   GET$ Z,1,G$
   GET$ Z,1,B$
   GET$ Z,1,RES$
   R = ASC(R$) * 63 / 255
   G = ASC(G$) * 63 / 255
   B = ASC(B$) * 63 / 255
   PAL(T, 0) = B
   PAL(T, 1) = G
   PAL(T, 2) = R
  NEXT
 CLOSE Z
END SUB

SUB LOADICONSPRITE (T$, G$)
 DIM PAL(255,2) AS BYTE
 X1 = 0
 Y1 = 0
 XM = 1
 YM = 1
 Z=FREEFILE
 OPEN "b", #Z, T$
  SEEK Z, 6
  GET$ Z,1,XA$
  GET$ Z,1,YA$
  GET$ Z,1,RLE$
  RLE = ASC(RLE$)
  IF RLE <> 16 THEN RLE = 256
  SEEK Z, 62
  FOR T = 0 TO RLE - 1
   GET$ Z,1,R$
   GET$ Z,1,G$
   GET$ Z,1,B$
   GET$ Z,1,RES$
   R = ASC(R$) * 63 / 255
   G = ASC(G$) * 63 / 255
   B = ASC(B$) * 63 / 255
   PAL(T, 0) = B
   PAL(T, 1) = G
   PAL(T, 2) = R
  NEXT
  XA = ASC(XA$) - 1
  YA = ASC(YA$) - 1
  DIM G(XA, YA)
  XD = 0
  YD = YA
  DO
   get$ Z,1,c$
   c = ASC(c$)
   A = c
   IF RLE = 16 THEN
    A = INT(c / 16)
    B = c - 16 * A
    G(XD + 1, YD) = B
   END IF
   G(XD, YD) = A
   XD = XD + 1
   IF RLE = 16 THEN XD = XD + 1
   IF XD>XA THEN XD=0:YD=YD-1:IF YD<0 THEN EXIT LOOP
  LOOP WHILE NOT EOF(Z)
 CLOSE Z
 G$ = CHR$(XA) + CHR$(YA)
 FOR Y = 0 TO YA
  FOR X = 0 TO XA
   G$ = G$ + CHR$(G(X, Y))
  NEXT
 NEXT
END SUB

SUB LOADING (M)
 RESTORE LOADDISK
 CALL VGASPRITE(0, YSCMAX - 16, M)
END SUB

SUB LOADSVB (FILE$, T$)
 ZI=FREEFILE
 OPEN "B", #ZI, FILE$
  GET$ ZI,9,S$
  IF S$ <> "SHAD.SVB " THEN PRINT "KEINE SHADOW VGA BLOCK FILE!": END
  Z = LOF(ZI) - SEEK(ZI)
  GET$ ZI,Z,T$
 CLOSE ZI
END SUB

$IF NOT %FASTPIXEL

SUB PIXEL (X1, Y1, c&)
 X& = X1
 Y& = Y1
' IF VGATX# <> 1 THEN X& = INT(VGATX# * X1)
' IF VGATY# <> 1 THEN Y& = INT(VGATY# * Y1)
 X&=X&-VESAXDECR
 Y&=Y&-VESAYDECR
 IF X& > ENDX%-1 OR X& < ANFX% OR Y& > ENDY%-1 OR Y& < ANFY% THEN EXIT SUB
 DO WHILE C& > CSCREEN - 1
  C& = C& - CSCREEN
 LOOP
 C=C&
 IF (VESATRANS%=1) AND (C=0) AND ((VESAHANDLE=-1) OR (VESAHANDLE=0)) THEN EXIT SUB
 IF (VESAONELOAD>0) AND (C=VESAONELOAD) THEN EXIT SUB
 IF MSCREEN = 13 THEN
  !mov ax,y&
  !mov bx,320
  !mul bx
  !mov bx,x&
  !add ax,bx
  !mov newoff&,ax
  VESAX% = X&
  VESAY% = Y&
  VESAOFF& = NEWOFF&
  SELECT CASE VESAEMS
   CASE 0
    SELECT CASE c
     CASE >= 0
      IF (VESAHANDLE>0) AND (VESATRANS%=1) THEN
       C=-1
       C=GETEMSBYTE(0,CSNG(NEWOFF&),VESAHANDLE)
      END IF
      C%=C
      !MOV AX,&HA000
      !MOV ES,AX
      !MOV AL,C%
      !MOV BX,NEWOFF&
      !MOV ES:[BX],AL
     CASE < 0
      C%=0
      !MOV AX,&HA000
      !MOV ES,AX
      !MOV BX,NEWOFF&
      !MOV AL,ES:[BX]
      !MOV C%,AL
      C=C%
    END SELECT
   CASE 1
    SELECT CASE C
     CASE >=0
      CALL PUTEMSBYTE(0,CSNG(NEWOFF&),C,VESAHANDLE)
     CASE < 0
      C=GETEMSBYTE(0,CSNG(NEWOFF&),VESAHANDLE)
    END SELECT
  END SELECT
 ELSE
  bpl&=bpline
  !mov ax,y&
  !mov bx,bpl&
  !mul bx
  !mov bx,x&
  !add ax,bx
  !adc dx,0
  !mov newoff&,ax
  !mov newwin&,dx
  VESAX% = X&
  VESAY% = Y&
  VESAOFF& = NEWOFF&
  WIN&=NEWWIN&
  SELECT CASE GRAN%
   CASE 1
    SHIFT SIGNED LEFT WIN&,6
   CASE 2
    SHIFT SIGNED LEFT WIN&,5
   CASE 4
    SHIFT SIGNED LEFT WIN&,4
   CASE 8
    SHIFT SIGNED LEFT WIN&,3
   CASE 16
    SHIFT SIGNED LEFT WIN&,2
   CASE 32
    SHIFT SIGNED LEFT WIN&,1
   CASE 64
   CASE ELSE
    WIN& = newwin& * 64 / GRAN%
  END SELECT
  WIN=WIN&
  SELECT CASE VESAEMS
   CASE 0
    SELECT CASE CSCREEN
     CASE 256
      SELECT CASE c
       CASE >= 0
        IF (VESAHANDLE>0) AND (VESATRANS%=1) THEN
         C=-1
         CALL VESA2EMS(WIN/(64/GRAN%),CSNG(NEWOFF&),PAGE,POFF)
         CALL EMSBYTE(PAGE,POFF,C,VESAHANDLE)
        END IF
        IF WIN <> VESAWINDOW THEN
         CALL SETVESAWINDOW(WIN)
         VESAWINDOW = WIN
        END IF
        C%=C
        !MOV AX,&HA000
        !MOV ES,AX
        !MOV BX,NEWOFF&
        !MOV AL,C%
        !MOV ES:[BX],AL
       CASE < 0
        IF WIN <> VESAWINDOW THEN
         CALL SETVESAWINDOW(WIN)
         VESAWINDOW = WIN
        END IF
        C%=1
        !MOV AX,&HA000
        !MOV ES,AX
        !MOV BX,NEWOFF&
        !MOV AL,ES:[BX]
        !MOV C%,AL
        C=C%
      END SELECT

     CASE 32768

     CASE 65536

     CASE 16777216
      SELECT CASE c
       CASE >= 0
        H=INT(C/65536)
        L=C MOD 65536
        B=L MOD 256
        G=INT(L/256)
        R=H MOD 256
        H=VESAOFF&
        DEF SEG = &HA000
        POKE H, R
        POKE H+1, G
        POKE H+2, B
       CASE < 0
        H=VESAOFF&
        DEF SEG = &HA000
        B = PEEK(H)
        G = PEEK(H+1)
        R = PEEK(H+2)
        C = R + 256 * G + 65536 * B
      END SELECT
    END SELECT
   CASE 1
    SELECT CASE C
     CASE >=0
      CALL VESA2EMS(WIN/(64/GRAN%),CSNG(NEWOFF&),PAGE,POFF)
      CALL EMSBYTE(PAGE,POFF,C,VESAHANDLE)
     CASE <0
      C=-1
      CALL VESA2EMS(WIN/(64/GRAN%),CSNG(NEWOFF&),PAGE,POFF)
      CALL EMSBYTE(PAGE,POFF,C,VESAHANDLE)
    END SELECT
  END SELECT
 END IF
 C&=C
END SUB

$ELSE
SUB PIXEL (BYVAL X%,BYVAL Y%, C&)
 C%=C&
 !MOV AX,X%
 !CMP AX,ANFX%
 !JBE PSETCPU4
 !CMP AX,ENDX%
 !JAE PSETCPU4
 !MOV AX,Y%
 !CMP AX,ANFY%
 !JBE PSETCPU4
 !CMP AX,ENDY%
 !JAE PSETCPU4
 !JMP PSETCPU3
 PSETCPU4:
 !JMP PSETCPU9
 PSETCPU3:
 !MOV AX,C%
 !CMP AX,-1
 !JE PSETCPU7
 !MOV CX,CSCREEN
 PSETCPU5:
 !CMP AX,CX
 !JB PSETCPU7
 !SUB AX,CX
 !MOV C%,AX
 !JMP PSETCPU5
 PSETCPU7:
 !MOV BX,VESATRANS%
 !CMP BX,1
 !JNE PSETCPU13
 !CMP AX,0
 !JNE PSETCPU13
 !JMP PSETCPU9
 PSETCPU13:
 !MOV AX,MSCREEN                 ;WENN MODUS 13H DANN
 !CMP AX,13
 !JNE PSETCPU8
 !mov ax,y%                      ;13H OFFSET BERECHNEN
 !MOV VESAY%,AX
 !mov bx,320
 !mul bx
 !mov bx,x%
 !MOV VESAX%,BX
 !add ax,bx
 !MOV BX,AX
 !MOV VESAOFF&,AX
 !MOV AX,C%
 !CMP AX,-1                     ;C=-1
 !JE PSETCPU1
 !PUSH ES
 !MOV AX,&HA000
 !MOV ES,AX
 !MOV AX,C%
 !XOR AH,AH
 !MOV ES:[BX],AL                ;PUNKT SETZEN
 !POP ES
 !JMP PSETCPU9
 PSETCPU1:
 !MOV AX,&HA000
 !MOV ES,AX
 !MOV AL,ES:[BX]                ;PUNKT LESEN
 !XOR AH,AH
 !MOV C%,AX
 !JMP PSETCPU9
 PSETCPU8:                      'VESA GRAFIK !
 !mov ax,y%                     ;VESAOFF=Y*BPLINE+X
 !mov bx,BPLINE
 !mul bx
 !mov bx,x%
 !add ax,bx
 !adc dx,0
 !mov vesaoff&,ax
 !MOV CL,GRAN%               ;WIN=WIN*64/GRAN
 !SHL DX,CL
 !CMP DX,VESAWINDOW          ;NEUES FENSTER ?
 !JE PSETCPU10
 !MOV VESAWINDOW,DX
 !MOV AX,&H4F05
 !MOV BX,&H0000
 !INT &H10
 PSETCPU10:
 !MOV AX,C%
 !CMP AX,-1                  ;C=-1 ?
 !JE PSETCPU11
 !MOV AX,&HA000
 !MOV ES,AX
 !MOV BX,VESAOFF&
 !MOV AX,C%                  ;PUNKT SETZEN
 !XOR AH,AH
 !MOV ES:[BX],AL
 !JMP PSETCPU9
 PSETCPU11:
 !MOV AX,&HA000
 !MOV ES,AX
 !MOV BX,VESAOFF&
 !MOV AL,ES:[BX]             ;PUNKT LESEN
 !XOR AH,AH
 !MOV C%,AX
 PSETCPU9:
 !MOV AX,C%
 !CMP AX,-1
 !JNE PSETCPU12
 !MOV AX,0
 !MOV C%,AX
 PSETCPU12:
 C&=C%
END SUB
$ENDIF

SUB PUTBOX(BYVAL XA AS WORD,BYVAL YA AS WORD,BYVAL T AS STRING)
 DIM OFFS AS WORD,SEGM AS WORD
 DIM X AS BYTE,Y AS BYTE,C AS BYTE
 OFFS=STRPTR(T)
 SEGM=STRSEG(T)
 !PUSH ES
 !PUSH DI
 !MOV DI,OFFS
 !MOV ES,SEGM
 !MOV CL,ES:[DI]
 !INC DI
 !MOV CH,ES:[DI]
 !MOV X?,0
 !MOV Y?,0
 SHWSPRLOOP1:
 !INC DI
 !MOV AL,ES:[DI]
 !MOV C?,AL
 !MOV OFFS,DI
 !POP DI
 !POP ES
 !PUSH CX
 IF C?<>VESAONELOAD THEN CALL PUTPIXEL(XA+X?,YA+Y?,(C?))
 !JMP SHWSPRLOOP3
 SHWSPRLOOP2:
 !JMP SHWSPRLOOP1
 SHWSPRLOOP3:
 !POP CX
 !PUSH ES
 !PUSH DI
 !MOV ES,SEGM
 !MOV DI,OFFS
 !INC X?
 !CMP X?,CL
 !JNE SHWSPRLOOP2
 !MOV X?,0
 !INC Y?
 !CMP Y?,CH
 !JNE SHWSPRLOOP2
 !POP DI
 !POP ES
END SUB

FUNCTION GETMASK(BYVAL XA AS WORD,BYVAL YA AS WORD,BYVAL T AS STRING) AS STRING
 DIM MAXX AS BYTE,MAXY AS BYTE
 MAXX=ASC(MID$(T,1,1))
 MAXY=ASC(MID$(T,2,1))
 DIM G AS STRING,U AS WORD
 G=T
 U=3
 FOR Y=0 TO MAXY-1
  FOR X=0 TO MAXX-1
   IF MID$(T,U,1)<>CHR$(0) THEN
    MID$(G,U,1)=CHR$(GETPIXEL(XA+X,YA+Y))
   END IF
   U=U+1
  NEXT
 NEXT
 GETMASK=G
END FUNCTION

SUB SETDECREASE(X,Y)
 VESAXDECR=X
 VESAYDECR=Y
END SUB

SUB PUTPIXEL(BYVAL X AS WORD,BYVAL Y AS WORD,BYVAL C AS WORD)
 IF X>XSCMAX OR Y>YSCMAX THEN EXIT SUB

 DIM XT AS WORD,YT AS WORD
 DIM X1 AS WORD,Y1 AS WORD
 DIM X2 AS WORD,Y2 AS WORD
 DIM AXT AS WORD,BXT AS WORD

 !PUSH DI
 !PUSH SI
 !PUSH ES
 !MOV AX,0
 !MOV ES,AX
 !MOV CX,KSCALE          ;KONSTANTEN
 !MOV DI,XSCALE          ; -||-
 !MOV SI,YSCALE          ; -||-
 !CMP DI,CX              ;VERGLEICHE X-SCALED IMAGE
 !PUSHF
 !POP AX
 !AND AX,6               ;ZERO FLAG RETTEN
 !CMP SI,CX              ;VERGLEICHE Y-SCALED IMAGE
 !PUSHF
 !POP BX
 !TEST AX,BX             ;ZERO FLAGS VERGLEICHEN
 !JZ LAB9
 !JMP LAB10
 LAB9:
 !MOV CX,X
 !MOV DX,Y
 !MOV AX,1
 !MOV ES,AX
 !JMP LAB7
 LAB10:
 !MOV AX,X               ;X*XSCALE/K
 !MUL DI
 !DIV CX
 !MOV X1,AX              ;XREAL 1.
 !MOV AX,Y               ;Y*YSCALE/K
 !MUL SI
 !DIV CX
 !MOV Y1,AX              ;YREAL 2.
 !CMP DI,CX
!JB LAB1
 !MOV AX,X
 !INC AX
 !MUL DI
 !DIV CX
 !MOV X2,AX              ;XR2 3.
!JMP LAB2
LAB1:
 !MOV AX,X1
 !MOV X2,AX              ;XR2 3.
LAB2:
 !CMP SI,CX
!JB LAB3
 !MOV AX,Y
 !INC AX
 !MUL SI
 !DIV CX
 !MOV Y2,AX              ;YR2 4.
!JMP LAB4
LAB3:
 !MOV AX,Y1
 !MOV Y2,AX              ;YR2 4.
LAB4:
 !MOV BX,Y2
 !MOV AX,X2
 !MOV DX,Y1

LAB5:
 !MOV CX,X1
LAB6:
 'NUR AUFRUF DER PIXEL MIT (XT,YT)
 '{
	!JMP LAB7
	LAB8:
 '}
 !INC CX
 !CMP CX,AX
!JB LAB6
 !INC DX
 !CMP DX,BX
!JB LAB5
!JMP LABZ
LAB7:                  'PUNKT SETZEN
     !MOV XT,CX
     !MOV YT,DX
     !MOV AXT,AX
     !MOV BXT,BX
     !PUSH ES
    	PIXEL XT+0,YT+0,C+0
     !MOV DX,YT
     !MOV CX,XT
     !MOV BX,BXT
     !POP AX
     !TEST AX,1           ;RšCKSPRUNG ZUR SCHLEIFE ODER EINZELPUNKT ?
     !JNZ LABZ
     !MOV ES,AX
     !MOV AX,AXT
!JMP LAB8
LABZ:
!POP ES
!POP SI
!POP DI
END SUB

SUB SAVESVB (FILE$, XA, YA, X, Y)
 Z=FREEFILE
 OPEN "B", #Z, FILE$
  PUT$ Z,"SHAD.SVB "
  PUT$ Z,CHR$(X)+CHR$(Y)
  FOR YT = YA TO YA + Y
   FOR XT = XA TO XA + X
    PUT$ Z,CHR$(GETPIXEL(XT,YT))
   NEXT
  NEXT
 CLOSE Z
END SUB

SUB RELOADSVB(FILE$,XA,YA)
 Z=FREEFILE
 OPEN "B", #Z, FILE$
  GET$ #Z,9,T$
  IF T$ <> "SHAD.SVB " THEN EXIT SUB
  GET$ #Z,1,X$
  GET$ #Z,1,Y$
  FOR YT = YA TO YA + ASC(Y$)
   GET$ #Z,ASC(X$),T$
   FOR XT = XA TO XA + ASC(X$)
    CALL PUTPIXEL(XT,YT,ASC(MID$(T$,XT-XA+1,1)))
   NEXT
  NEXT
 CLOSE Z
END SUB

SUB SAVEBLOCK(FILE$,T$)
 Z=FREEFILE
 OPEN "B",#Z,FILE$
  PUT$ #Z,"SHAD.SVB "
  PUT$ #Z,T$
 CLOSE Z
END SUB

SUB SETRES (X, Y, c)
 'for VMWARE
 'SETVGA 13
 'SETVGAWINDOW X,Y
 'EXIT SUB

 DIM XD AS INTEGER,YD AS INTEGER,VD AS WORD
 IF (X=320) AND (Y=200) AND (C=256) THEN
  SETVGA 13
  EXIT SUB
 END IF
 T$ = STRING$(256, 219)
 T2$ = STRING$(256, 219)
 REG 1, &H4F00
 REG 6, STRPTR(T$)
 REG 9, STRSEG(T$)
 CALL INTERRUPT &H10
 FAROFF = ASC(MID$(T$, 15, 1)) + 256 * ASC(MID$(T$, 16, 1))
 FARSEG = ASC(MID$(T$, 17, 1)) + 256 * ASC(MID$(T$, 18, 1))
 DEF SEG = FARSEG
 'SEARCH MODE
 Z=0
 DO
  U = PEEK(FAROFF + Z) + 256 * PEEK(FAROFF + Z + 1)
  REG 1, &H4F01
  REG 3, U
  REG 9, STRSEG(T2$)
  REG 6, STRPTR(T2$)
  CALL INTERRUPT &H10
  XMAX = ASC(MID$(T2$, &H13, 1)) + 256 * ASC(MID$(T2$, &H14, 1))
  YMAX = ASC(MID$(T2$, &H15, 1)) + 256 * ASC(MID$(T2$, &H16, 1))
  CMAX = 2 ^ ASC(MID$(T2$, &H1A, 1))
  IF X = XMAX AND Y = YMAX AND c = CMAX THEN CALL SETVGA(U): EXIT SUB
  Z = Z + 2
  TESTX = PEEK(FAROFF + Z) + 256 * PEEK(FAROFF + Z + 1)
 LOOP UNTIL TESTX = 65535

 'SIMULATE MODE WITH HIGHER RES
 Z=0
 XD=32767
 YD=32767
 VD=0
 DO
  U = PEEK(FAROFF + Z) + 256 * PEEK(FAROFF + Z + 1)
  REG 1, &H4F01
  REG 3, U
  REG 9, STRSEG(T2$)
  REG 6, STRPTR(T2$)
  CALL INTERRUPT &H10
  XMAX = ASC(MID$(T2$, &H13, 1)) + 256 * ASC(MID$(T2$, &H14, 1))
  YMAX = ASC(MID$(T2$, &H15, 1)) + 256 * ASC(MID$(T2$, &H16, 1))
  CMAX = 2 ^ ASC(MID$(T2$, &H1A, 1))
  IF (XMAX-X<=XD) AND (YMAX-Y<=YD) AND (c = CMAX) THEN
   IF (XMAX-X>=0) AND (YMAX-Y>=0) THEN
    XD=XMAX-X
    YD=YMAX-Y
    VD=U
   END IF
  END IF
  Z = Z + 2
  TESTX = PEEK(FAROFF + Z) + 256 * PEEK(FAROFF + Z + 1)
 LOOP UNTIL TESTX = 65535
 IF (320-X<=XD) AND (200-Y<=YD) AND (c = 256) THEN
  IF (320-X>=0) AND (200-Y>=0) THEN
   VD=13
  END IF
 END IF
 IF VD>0 THEN
  SETVGA VD
  SETVGAWINDOW X,Y
  EXIT SUB
 END IF

 'SEARCH HIGHEST RES AND MATCH
 Z=0
 XD=32767
 YD=32767
 VD=0
 DO
  U = PEEK(FAROFF + Z) + 256 * PEEK(FAROFF + Z + 1)
  REG 1, &H4F01
  REG 3, U
  REG 9, STRSEG(T2$)
  REG 6, STRPTR(T2$)
  CALL INTERRUPT &H10
  XMAX = ASC(MID$(T2$, &H13, 1)) + 256 * ASC(MID$(T2$, &H14, 1))
  YMAX = ASC(MID$(T2$, &H15, 1)) + 256 * ASC(MID$(T2$, &H16, 1))
  CMAX = 2 ^ ASC(MID$(T2$, &H1A, 1))
  IF (X-XMAX<=XD) AND (Y-YMAX<=YD) AND (c = CMAX) THEN
   XD=X-XMAX
   YD=Y-YMAX
   VD=U
  END IF
  Z = Z + 2
  TESTX = PEEK(FAROFF + Z) + 256 * PEEK(FAROFF + Z + 1)
 LOOP UNTIL TESTX = 65535
 IF (X-320<=XD) AND (Y-200<=YD) AND (c = 256) THEN
  VD=13
 END IF
 IF VD>0 THEN
  SETVGA VD
  SETVGAWINDOW X,Y
  EXIT SUB
 ELSE
  CLOSEVGA
  PRINT "VESA MODUS NICHT UNTERSTšTZT !"
  END
 END IF

END SUB

SUB SETVGA (BYVAL TINT AS INTEGER)
 IF TINT = 13 THEN
  !MOV AX,&H13
  !INT &H10
  XSCREEN = 320
  YSCREEN = 200
  BPLINE = 320
  GRAN% = 0
  MSCREEN = 13
  CSCREEN = 256
  BPP% = 8
 ELSE
  T$ = STRING$(256, 219)
  SEGMENT = STRSEG(T$)
  OFFSET = STRPTR(T$)
  REG 1, &H4F01
  REG 3, TINT
  REG 9, SEGMENT
  REG 6, OFFSET
  CALL INTERRUPT &H10
  DEF SEG = SEGMENT
  GRAN% = PEEK(OFFSET + 4) + 256 * PEEK(OFFSET + 5)
  IF GRAN% < 1 THEN GRAN%=1
  BPLINE = PEEK(OFFSET + &H10) + 256 * PEEK(OFFSET + &H11)
  XSCREEN = PEEK(OFFSET + &H12) + 256 * PEEK(OFFSET + &H13)
  YSCREEN = PEEK(OFFSET + &H14) + 256 * PEEK(OFFSET + &H15)
  BPP% = ASC(MID$(T$, &H1A, 1))
  CSCREEN = 2 ^ ASC(MID$(T$, &H1A, 1))
  MSCREEN = TINT
  REG 1, &H4F02
  REG 2, TINT
  CALL INTERRUPT &H10
 END IF
 VESAWINDOW = 0
 VESAX% = 0
 VESAY% = 0
 VESAOFF& = 0
 ANFX% = 0
 ANFY% = 0
 ENDX% = XSCREEN
 ENDY% = YSCREEN
 VESAXDECR=0
 VESAYDECR=0
 KSCALE=128
 XSCALE=KSCALE
 YSCALE=KSCALE
 XSCMAX=XSCREEN
 YSCMAX=YSCREEN
END SUB

SUB SETVGAWINDOW(BYVAL XMAX AS WORD,BYVAL YMAX AS WORD)
 'XR=XV*XSCREEN/XMAX
 'XR=XV*   XSCALE
 XSCALE=XSCREEN/XMAX*KSCALE
 YSCALE=YSCREEN/YMAX*KSCALE
 XSCMAX=XMAX
 YSCMAX=YMAX
END SUB

SUB SHOWBMP (FILE$, XA, YA)
 Z=FREEFILE
 OPEN FILE$ FOR BINARY AS #Z
  SEEK Z, &HA
  GET$ Z,4,A$
  OFFDATA = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  SEEK Z, &H12
  GET$ Z,4,A$
  XMAX = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  GET$ Z,4,A$
  YMAX = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  SEEK Z, &H1C
  GET$ Z,2,T$
  C=2^(ASC(LEFT$(T$,1))+256*ASC(RIGHT$(T$,1)))
  SEEK Z, &H36
  FOR T% = 0 TO C-1
   GET$ Z,1,B$
   GET$ Z,1,G$
   GET$ Z,1,R$
   GET$ Z,1,I$
   OUT &H3C8, T%
   OUT &H3C9, ASC(R$) * 63 / 255
   OUT &H3C9, ASC(G$) * 63 / 255
   OUT &H3C9, ASC(B$) * 63 / 255
  NEXT
  SEEK Z, OFFDATA
  IF XMAX=30 THEN XMAX=XMAX+2
  IF XMAX=15 THEN XMAX=XMAX+1
  SELECT CASE C
   CASE 256
    y=ymax-1
    do
     GET$ Z,XMAX,C$
     FOR X = 0 TO XMAX - 1
      IF VESABMP=0 THEN
       CALL PUTPIXEL(X + XA, Y + YA, ASC(MID$(c$, X + 1, 1)))
      ELSE
       IF X>=BMPX1 AND X<=BMPX2 AND Y>=BMPY1 AND Y<=BMPY2 THEN CALL PUTPIXEL(X + XA - BMPX1, Y + YA - BMPY1, ASC(MID$(c$, X + 1, 1)))
      END IF
     NEXT
     y=y-1
    loop until y<0
   CASE 16
    y=ymax-1
    do
     T=INT(XMAX/2+2)
     'IF T<>INT(T) THEN T=INT(T)+1
     GET$ Z,T,C$
     FOR X = 0 TO T-3
      CALL PUTPIXEL(X*2+0+XA, Y+YA, ASC(MID$(c$, X + 1, 1)) MOD 16)
      CALL PUTPIXEL(X*2+1+XA, Y+YA, INT(ASC(MID$(c$, X + 1, 1)) /16))
     NEXT
     y=y-1
    loop until y<0
  END SELECT
 CLOSE Z
END SUB

SUB SHOWBMPRAW (FILE$, XA, YA)
 Z=FREEFILE
 OPEN FILE$ FOR BINARY AS #Z
  SEEK Z, &HA
  GET$ Z,4,A$
  OFFDATA = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  SEEK Z, &H12
  GET$ Z,4,A$
  XMAX = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  GET$ Z,4,A$
  YMAX = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  SEEK Z, &H1C
  GET$ #Z,2,T$
  C=2^(ASC(LEFT$(T$,1))+256*ASC(RIGHT$(T$,1)))
  SEEK Z, OFFDATA
  IF XMAX=30 THEN XMAX=XMAX+2
  IF XMAX=15 THEN XMAX=XMAX+1
  SELECT CASE C
   CASE 256
    y=ymax-1
    do
     GET$ Z,XMAX,C$
     FOR X = 0 TO XMAX - 1
      IF VESABMP=0 THEN
       CALL PUTPIXEL(X + XA, Y + YA, asc(mid$(c$,x+1,1)))
      ELSE
       IF X>=BMPX1 AND X<=BMPX2 AND Y>=BMPY1 AND Y<=BMPY2 THEN CALL PUTPIXEL(X + XA - BMPX1, Y + YA - BMPY1, ASC(MID$(c$, X + 1, 1)))
      END IF
     NEXT
     y=y-1
    loop until y<0
   CASE 16
    y=ymax-1
    do
     T=XMAX/2+2
     IF T<>INT(T) THEN T=INT(T)+1
     GET$ Z,T,C$
     FOR X = 0 TO T-3
      CALL PUTPIXEL(X*2+0+XA, Y+YA, ASC(MID$(c$, X + 1, 1)) MOD 16)
      CALL PUTPIXEL(X*2+1+XA, Y+YA, INT(ASC(MID$(c$, X + 1, 1)) /16))
     NEXT
     y=y-1
    loop until y<0
  END SELECT
 CLOSE Z
END SUB

SUB SHOW256BMP(BYVAL F$,BYVAL XA AS WORD,BYVAL YA AS WORD)
 DIM GSTR AS ASCIIZ*4096
 GSTR=F$
 DIM FSEG AS WORD,FOFF AS WORD
 DIM HAND AS WORD
 DIM XMAX AS WORD,YMAX AS WORD
 DIM HOFF AS WORD,LOFF AS WORD

 FSEG=VARSEG(GSTR)
 FOFF=VARPTR(GSTR)
 SSEG=VARSEG(BUFF)
 SOFF=VARPTR(BUFF)

 !PUSH DS
 !MOV AX,&H3D00
 !MOV DX,FOFF
 !MOV BX,FSEG
 !MOV DS,BX
 !INT &H21
 !POP DS
 !JC FBMPLAB1
 !MOV HAND,AX
 !JMP FBMPLAB2
 FBMPLAB1:
 'FILE GIBS NICH

 !JMP FBMPLABZ
 FBMPLAB2:
 'GEHT AUF
 !MOV AX,&H4200
 !MOV BX,HAND
 !XOR CX,CX
 !MOV DX,&H0A
 !INT &H21
 !PUSH DS
 !MOV AX,FSEG
 !MOV DX,FOFF
 !MOV DS,AX
 !MOV AH,&H3F
 !MOV CX,4
 !INT &H21
 !MOV SI,DX
 !MOV AX,WORD PTR DS:[SI]
 !ADD SI,4
 !MOV BX,WORD PTR DS:[SI]
 !POP DS
 !MOV LOFF,AX
 !MOV HOFF,BX
 !MOV AX,&H4200
 !MOV BX,HAND
 !XOR CX,CX
 !MOV DX,&H12
 !INT &H21
 !PUSH DS
 !MOV AX,FSEG
 !MOV DX,FOFF
 !MOV DS,AX
 !MOV AH,&H3F
 !MOV CX,8
 !INT &H21
 !MOV SI,DX
 !MOV AX,WORD PTR DS:[SI]
 !ADD SI,4
 !MOV BX,WORD PTR DS:[SI]
 !POP DS
 !MOV XMAX,AX
 !MOV YMAX,BX

 !MOV AH,&H42
 !MOV CX,HOFF
 !MOV DX,LOFF
 !MOV BX,HAND
 !INT &H21

 !MOV SI,YMAX
 !DEC SI
 !PUSH DS
 FBMPLOOP1:
 !POP DS
 !MOV CX,XMAX
 !PUSH DS
 FBMPLOOP2:

       'SCHLEIFE ZUM EINLESEN UND ANZEIGEN !

 !POP DS
 !MOV AH,&H3E
 !MOV BX,HAND
 !INT &H21
 FBMPLABZ:
END SUB

SUB GETBMPSIZE(T$,X,Y)
 Z=FREEFILE
 OPEN T$ FOR BINARY AS #Z
  SEEK Z, &H12
  GET$ Z,4,A$
  X = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  GET$ Z,4,A$
  Y = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
 CLOSE Z
END SUB

SUB SHOWBMPRAWLINE (FILE$, XA, YA)
 Z=FREEFILE
 OPEN FILE$ FOR BINARY AS #Z
  SEEK Z, &HA
  GET$ Z,4,A$
  OFFDATA = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  SEEK Z, &H12
  GET$ Z,4,A$
  XMAX = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  GET$ Z,4,A$
  YMAX = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  SEEK Z, &H1C
  GET$ #Z,2,T$
  C=2^(ASC(LEFT$(T$,1))+256*ASC(RIGHT$(T$,1)))
  SEEK Z, OFFDATA
  IF XMAX=30 THEN XMAX=XMAX+2
  IF XMAX=15 THEN XMAX=XMAX+1
  SELECT CASE C
   CASE 256
    y=ymax-1
    do
     GET$ Z,XMAX,C$
     FOR X = 0 TO XMAX - 1
      CALL LINEDRAW(X + XA, 0, X + XA, Y + YA, ASC(MID$(c$, X + 1, 1)))
     NEXT
     y=y-1
    loop until y<0
   CASE 16
    y=ymax-1
    do
     T=XMAX/2+2
     IF T<>INT(T) THEN T=INT(T)+1
     GET$ Z,T,C$
     FOR X = 0 TO T-3
      CALL LINEDRAW(X*2+0+XA,0,X*2+0+XA, Y+YA, ASC(MID$(c$, X + 1, 1)) MOD 16)
      CALL LINEDRAW(X*2+1+XA,0,X*2+1+XA, Y+YA, INT(ASC(MID$(c$, X + 1, 1)) /16))
     NEXT
     y=y-1
    loop until y<0
  END SELECT
 CLOSE Z
END SUB

SUB SHOWICON (T$, X1, Y1)
 XBAK=X1
 YBAK=Y1

 ICOFILE$=T$
 Z=FREEFILE
 OPEN "B",#Z,T$
  GET$ #Z,2,SIGNATUR$
  GET$ #Z,2,FILETYP$
  GET$ #Z,2,ICONUM$
  IF SIGNATUR$<>CHR$(0)+CHR$(0) THEN
   CALL CLOSEVGA
   PRINT "KEINE ICO-FILE"
   CLOSE Z
   END
  END IF
  NUM=ASC(LEFT$(ICONUM$,1))+256*ASC(RIGHT$(ICONUM$,1))
  IF NUM=0 THEN
   CALL CLOSEVGA
   PRINT "KEINE ICONS ENTHALTEN !"
   CLOSE Z
   END
  END IF
  DIM ICONARRAY(NUM,3)
  FOR T=1 TO NUM
   GET$ #Z,1,WIDHT$
   GET$ #Z,1,HEIGHT$
   GET$ #Z,1,COLORS$
   GET$ #Z,5,RESERVED$
   GET$ #Z,4,PICSIZE$
   GET$ #Z,4,PICOFFSET$
   ICONARRAY(T,0)=ASC(WIDHT$)
   ICONARRAY(T,1)=ASC(HEIGHT$)
   ICONARRAY(T,2)=ASC(COLORS$)
   IF ICONARRAY(T,2)<>16 THEN ICONARRAY(T,2)=256
   ICONARRAY(T,3)=(ASC(LEFT$(PICOFFSET$,1))+256*ASC(MID$(PICOFFSET$,2,1)))+65536*(ASC(MID$(PICOFFSET$,3,1))+256*ASC(RIGHT$(PICOFFSET$,1)))
  NEXT
  FOR T=1 TO NUM
   SEEK #Z,ICONARRAY(T,3)
   GET$ #Z,40,RESERVED$
   FOR C=0 TO ICONARRAY(T,2)-1
    GET$ #Z,1,R$
    GET$ #Z,1,G$
    GET$ #Z,1,B$
    GET$ #Z,1,T$
    OUT &H3C8,C
    OUT &H3C9,ASC(B$)\4
    OUT &H3C9,ASC(G$)\4
    OUT &H3C9,ASC(R$)\4
   NEXT
   IF ICONARRAY(T,2)=16 THEN
    DIM C(15,2)
    C(1,0)=42
    C(2,1)=42
    C(3,0)=42
    C(3,1)=42
    C(4,2)=42
    C(5,0)=42
    C(5,2)=42
    C(6,1)=42
    C(6,2)=42
    C(7,0)=42
    C(7,1)=42
    C(7,2)=42
    C(8,0)=21
    C(8,1)=21
    C(8,2)=21
    C(9,0)=63
    C(10,1)=63
    C(11,0)=63
    C(11,1)=63
    C(12,2)=63
    C(13,0)=63
    C(13,2)=63
    C(14,1)=63
    C(14,2)=63
    C(15,0)=63
    C(15,1)=63
    C(15,2)=63
    FOR C=0 TO 15
     OUT &H3C8,C
     OUT &H3C9,C(C,0)
     OUT &H3C9,C(C,1)
     OUT &H3C9,C(C,2)
    NEXT
    ERASE C()
   END IF
   Y=ICONARRAY(T,1)
   DO
    X=0
    DO
     GET$ #Z,1,A$
     A=ASC(A$+CHR$(0))
     IF ICONARRAY(T,2)=16 THEN
      B=A MOD 16
      A=INT(A/16)
      X=X+1
      CALL PUTPIXEL(X+X1,Y+Y1,B)
     END IF
     CALL PUTPIXEL(X-1+X1,Y+Y1,A)
     X=X+1
    LOOP WHILE X<ICONARRAY(T,0)
    Y=Y-1
   LOOP WHILE Y>0
   X1=X1+ICONARRAY(T,0)
  NEXT
 CLOSE Z
 T$=ICOFILE$
 X1=XBAK
 Y1=YBAK
END SUB

SUB SHOWICONSIZED (T$, X1, Y1,XR,YR)
 ICOFILE$=T$
 Z=FREEFILE
 OPEN "B",#Z,T$
  GET$ #Z,2,SIGNATUR$
  GET$ #Z,2,FILETYP$
  GET$ #Z,2,ICONUM$
  IF SIGNATUR$<>CHR$(0)+CHR$(0) THEN
   CALL CLOSEVGA
   PRINT "KEINE ICO-FILE"
   CLOSE Z
   END
  END IF
  NUM=ASC(LEFT$(ICONUM$,1))+256*ASC(RIGHT$(ICONUM$,1))
  IF NUM=0 THEN
   CALL CLOSEVGA
   PRINT "KEINE ICONS ENTHALTEN !"
   CLOSE Z
   END
  END IF
  DIM ICONARRAY(NUM,3)
  FOR T=1 TO NUM
   GET$ #Z,1,WIDHT$
   GET$ #Z,1,HEIGHT$
   GET$ #Z,1,COLORS$
   GET$ #Z,5,RESERVED$
   GET$ #Z,4,PICSIZE$
   GET$ #Z,4,PICOFFSET$
   ICONARRAY(T,0)=ASC(WIDHT$)
   ICONARRAY(T,1)=ASC(HEIGHT$)
   ICONARRAY(T,2)=ASC(COLORS$)
   IF ICONARRAY(T,2)<>16 THEN ICONARRAY(T,2)=256
   ICONARRAY(T,3)=(ASC(LEFT$(PICOFFSET$,1))+256*ASC(MID$(PICOFFSET$,2,1)))+65536*(ASC(MID$(PICOFFSET$,3,1))+256*ASC(RIGHT$(PICOFFSET$,1)))
  NEXT
  FOR T=1 TO NUM
   SEEK #Z,ICONARRAY(T,3)
   GET$ #Z,40,RESERVED$
   FOR C=0 TO ICONARRAY(T,2)-1
    GET$ #Z,1,R$
    GET$ #Z,1,G$
    GET$ #Z,1,B$
    GET$ #Z,1,T$
    OUT &H3C8,C
    OUT &H3C9,ASC(B$)\4
    OUT &H3C9,ASC(G$)\4
    OUT &H3C9,ASC(R$)\4
   NEXT
   IF ICONARRAY(T,2)=16 THEN
    DIM C(15,2)
    C(1,0)=42
    C(2,1)=42
    C(3,0)=42
    C(3,1)=42
    C(4,2)=42
    C(5,0)=42
    C(5,2)=42
    C(6,1)=42
    C(6,2)=42
    C(7,0)=42
    C(7,1)=42
    C(7,2)=42
    C(8,0)=21
    C(8,1)=21
    C(8,2)=21
    C(9,0)=63
    C(10,1)=63
    C(11,0)=63
    C(11,1)=63
    C(12,2)=63
    C(13,0)=63
    C(13,2)=63
    C(14,1)=63
    C(14,2)=63
    C(15,0)=63
    C(15,1)=63
    C(15,2)=63
    FOR C=0 TO 15
     OUT &H3C8,C
     OUT &H3C9,C(C,0)
     OUT &H3C9,C(C,1)
     OUT &H3C9,C(C,2)
    NEXT
    ERASE C()
   END IF
   Y=ICONARRAY(T,1)
   DO
    X=0
    DO
     GET$ #Z,1,A$
     A=ASC(A$+CHR$(0))
     IF ICONARRAY(T,2)=16 THEN
      B=A MOD 16
      A=INT(A/16)
      X=X+1
      CALL BOX((X-1)*XR+X1,(Y-1)*YR+Y1,X*XR+X1-1,Y*YR+Y1-1,(B))
     END IF
     CALL BOX((X-2)*XR+X1,(Y-1)*YR+Y1,(X-1)*XR+X1-1,Y*YR+Y1-1,(A))
     X=X+1
    LOOP WHILE X<ICONARRAY(T,0)
    Y=Y-1
   LOOP WHILE Y>0
   X1=X1+ICONARRAY(T,0)*XR
  NEXT
 CLOSE Z
 T$=ICOFILE$
END SUB

SUB SHOWPCX (N$, XPLUS, YPLUS)
 Z=FREEFILE
 OPEN N$ FOR BINARY AS #Z
  GET$ #Z,1,ID$
  ID = ASC(ID$)
  IF ID <> 10 THEN ERROR 5
  GET$ #Z,1,VER$
  VER = ASC(VER$)
  SELECT CASE VER
   CASE 0
    T = 2.5
   CASE 2
    T = 2.8
   CASE 3
    T = 2.7
   CASE 4
    T = 2.9
   CASE 5
    T = 3!
   CASE ELSE
    ERROR 5
  END SELECT
  VER = T
  GET$ #Z,1,FL$
  FL = ASC(FL$)
  IF FL = 0 THEN
   RLE = 0
  ELSEIF FL = 1 THEN
   RLE = 1
  ELSE
   ERROR 5
  END IF
  GET$ #Z,1,BITs$
  BITs = ASC(BITs$)
  col = 2 ^ BITs
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  XMIN = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  YMIN = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  XMAX = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  YMAX = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  HDPI = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  VDPI = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,48,CMAP$
  MAXFILE = LOF(Z) + 1
  IF col > 16 THEN
   V = SEEK(Z)
   SEEK Z, LOF(Z) - 769
   GET$ #Z,1,A$
   FOR T = 0 TO 255
    GET$ #Z,1,R$
    GET$ #Z,1,G$
    GET$ #Z,1,B$
    R = ASC(R$)
    G = ASC(G$)
    B = ASC(B$)
    RP = R * 100 / 255
    GP = G * 100 / 255
    BP = B * 100 / 255
    R = RP * 63 / 100
    G = GP * 63 / 100
    B = BP * 63 / 100
    OUT &H3C8, T
    OUT &H3C9, R
    OUT &H3C9, G
    OUT &H3C9, B
   NEXT
   SEEK Z, V
   MAXFILE = LOF(Z) - 769
  END IF
  GET$ #Z,1,DUMP$
  GET$ #Z,1,P$
  PLANES = ASC(P$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  BPL = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  PALI = ASC(T$) + 256 * ASC(G$)
  IF PALI > 2 OR PALI < 1 THEN ERROR 5
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  HBG = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  VBG = ASC(T$) + 256 * ASC(G$)
  SEEK Z, 128
  XMIN = XMIN + XPLUS
  XMAX = XMAX + XPLUS
  YMIN = YMIN + YPLUS
  YMAX = YMAX + YPLUS
  X = XMIN
  Y = YMIN
  DO
   GET$ #Z,1,A$
   A = ASC(A$)
   SELECT CASE RLE
    CASE 1
     SELECT CASE A
      CASE <= &HC0
       CALL PUTPIXEL(X, Y, A)
       X = X + 1
       IF X > XMAX THEN X = XMIN: Y = Y + 1
      CASE ELSE
       GET$ #Z,1,B$
       FOR T = X TO X + A - &HC1
        CALL PUTPIXEL(T, Y, ASC(B$))
       NEXT
       X = T
       IF X > XMAX THEN X = XMIN: Y = Y + 1
     END SELECT
    CASE 0
     CALL PUTPIXEL(X, Y, A)
     X = X + 1
     IF X > XMAX THEN X = XMIN: Y = Y + 1
   END SELECT
  LOOP WHILE SEEK(Z) < MAXFILE
 CLOSE #Z
END SUB

SUB SHOWPCXRAW (N$, XPLUS, YPLUS)
 Z=FREEFILE
 OPEN N$ FOR BINARY AS #Z
  GET$ #Z,1,ID$
  ID = ASC(ID$)
  IF ID <> 10 THEN ERROR 5
  GET$ #Z,1,VER$
  VER = ASC(VER$)
  SELECT CASE VER
   CASE 0
    T = 2.5
   CASE 2
    T = 2.8
   CASE 3
    T = 2.7
   CASE 4
    T = 2.9
   CASE 5
    T = 3!
   CASE ELSE
    ERROR 5
  END SELECT
  VER = T
  GET$ #Z,1,FL$
  FL = ASC(FL$)
  IF FL = 0 THEN
   RLE = 0
  ELSEIF FL = 1 THEN
   RLE = 1
  ELSE
   ERROR 5
  END IF
  GET$ #Z,1,BITs$
  BITs = ASC(BITs$)
  col = 2 ^ BITs
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  XMIN = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  YMIN = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  XMAX = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  YMAX = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  HDPI = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  VDPI = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,48,CMAP$
  MAXFILE = LOF(Z) + 1
  IF col > 16 THEN
   V = SEEK(Z)
   SEEK Z, LOF(Z) - 769
   GET$ #Z,1,A$
   FOR T = 0 TO 255
    GET$ #Z,1,R$
    GET$ #Z,1,G$
    GET$ #Z,1,B$
    R = ASC(R$)
    G = ASC(G$)
    B = ASC(B$)
    RP = R * 100 / 255
    GP = G * 100 / 255
    BP = B * 100 / 255
    R = RP * 63 / 100
    G = GP * 63 / 100
    B = BP * 63 / 100
   NEXT
   SEEK Z, V
   MAXFILE = LOF(Z) - 769
  END IF
  GET$ #Z,1,DUMP$
  GET$ #Z,1,P$
  PLANES = ASC(P$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  BPL = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  PALI = ASC(T$) + 256 * ASC(G$)
  IF PALI > 2 OR PALI < 1 THEN ERROR 5
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  HBG = ASC(T$) + 256 * ASC(G$)
  GET$ #Z,1,T$
  GET$ #Z,1,G$
  VBG = ASC(T$) + 256 * ASC(G$)
  SEEK Z, 128
  XMIN = XMIN + XPLUS
  XMAX = XMAX + XPLUS
  YMIN = YMIN + YPLUS
  YMAX = YMAX + YPLUS
  X = XMIN
  Y = YMIN
  DO
   GET$ #Z,1,A$
   A = ASC(A$)
   SELECT CASE RLE
    CASE 1
     SELECT CASE A
      CASE <= &HC0
       CALL PUTPIXEL(X, Y, A)
       X = X + 1
       IF X > XMAX THEN X = XMIN: Y = Y + 1
      CASE ELSE
       GET$ #Z,1,B$
       FOR T = X TO X + A - &HC1
        CALL PUTPIXEL(T, Y, ASC(B$))
       NEXT
       X = T
       IF X > XMAX THEN X = XMIN: Y = Y + 1
     END SELECT
    CASE 0
     CALL PUTPIXEL(X, Y, A)
     X = X + 1
     IF X > XMAX THEN X = XMIN: Y = Y + 1
   END SELECT
  LOOP WHILE SEEK(Z) < MAXFILE
 CLOSE #Z
END SUB

SUB SHOWSPRITE (XA, YA, S$, T$)
 IF T$ <> "" THEN
  OX = ASC(MID$(T$, 1, 1)) + 256 * ASC(MID$(T$, 2, 1))
  OY = ASC(MID$(T$, 3, 1)) + 256 * ASC(MID$(T$, 4, 1))
  Z$ = RIGHT$(T$, LEN(T$) - 4)
  CALL PUTBOX(OX, OY, Z$)
 END IF
 XM = ASC(MID$(S$, 1, 1))
 YM = ASC(MID$(S$, 2, 1))
 IF XA >= 0 AND YA >= 0 THEN
  T$=GETBOX(XA, YA, XA + XM + 1, YA + YM + 1)
  T$ = CHR$(XA MOD 256) + CHR$(INT(XA / 256)) + CHR$(YA MOD 256) + CHR$(INT(YA / 256)) + T$
 ELSEIF XA < 0 THEN
  T$=GETBOX(0, YA, 0 + XM + 1, YA + YM + 1)
  T$ = CHR$(0) + CHR$(0) + CHR$(YA MOD 256) + CHR$(INT(YA / 256)) + T$
 ELSEIF YA < 0 THEN
  T$=GETBOX(XA, 0, XA + XM + 1, 0 + YM + 1)
  T$ = CHR$(XA MOD 256) + CHR$(INT(XA / 256)) + CHR$(0) + CHR$(0) + T$
 ELSE
  T$=GETBOX(0, 0, 0 + XM + 1, 0 + YM + 1)
  T$ = CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + T$
 END IF
 CALL PUTBOX(X,Y,S$)
' FOR Y = 0 TO YM
'  FOR X = 0 TO XM
'   P = ASC(MID$(S$, 3 + X + (XM + 1) * Y, 1))
'   IF P > 0 THEN CALL PUTPIXEL(X + XA, Y + YA, P)
'  NEXT
' NEXT
END SUB
$SEGMENT

SUB SPRITESET (X, Y, XDIFF, YDIFF, rot, col$)
 DIM col(15)
 IF col$ <> "" THEN
  FOR T = 1 TO LEN(col$)
   col(T - 1) = VAL("&H" + MID$(col$, T, 1))
  NEXT
 ELSE
  FOR T = 0 TO 15
   col(T) = T
  NEXT
 END IF
 OLDX = X
 OLDY = Y
 SELECT CASE rot
  CASE 0
   DO
    READ T$
    FOR T = 1 TO LEN(T$) STEP 2
     IF MID$(t$, t, 2) = "99" THEN EXIT LOOP
     IF MID$(T$, T, 2) <> "hg" THEN CALL BOX(X, Y, X + XDIFF, Y + YDIFF, (col(VAL(MID$(T$, T, 2)))))
     X = X + XDIFF
    NEXT
    Y = Y + YDIFF
    X = OLDX
   LOOP UNTIL RIGHT$(T$, 2) = "99"
  CASE 1
   DO
    READ T$
    FOR T = 1 TO LEN(T$) STEP 2
     IF MID$(t$, t, 2) = "99" THEN EXIT LOOP
     IF MID$(T$, T, 2) <> "hg" THEN CALL BOX((OLDX + LEN(T$) / 2) - X + OLDX, Y, (OLDX + LEN(T$) / 2) - X + XDIFF, Y + YDIFF, (col(VAL(MID$(T$, T, 2)))))
     X = X + XDIFF
    NEXT
    Y = Y + YDIFF
    X = OLDX
   LOOP UNTIL RIGHT$(T$, 2) = "99"
  CASE 2
   DO
    READ T$
    FOR T = 1 TO LEN(T$) STEP 2
     IF MID$(t$, t, 2) = "99" THEN EXIT LOOP
     IF MID$(T$, T, 2) <> "hg" THEN CALL BOX((OLDX + LEN(T$) / 2) - X + OLDX, OLDY - Y + OLDY, (OLDX + LEN(T$) / 2) - X + OLDX + XDIFF, OLDY - Y + OLDY + YDIFF,( col(VAL(MID$(T$, T, 2)))))
     X = X + XDIFF
    NEXT
    Y = Y + YDIFF
    X = OLDX
   LOOP UNTIL RIGHT$(T$, 2) = "99"
  CASE 3
   DO
    READ T$
    FOR T = 1 TO LEN(T$) STEP 2
     IF MID$(t$, t, 2) = "99" THEN EXIT LOOP
     IF MID$(T$, T, 2) <> "hg" THEN CALL BOX(X, OLDY - Y + OLDY, X + XDIFF, OLDY - Y + OLDY + YDIFF, (col(VAL(MID$(T$, T, 2)))))
     X = X + XDIFF
    NEXT
    Y = Y + YDIFF
    X = OLDX
   LOOP UNTIL RIGHT$(T$, 2) = "99"
  CASE 4
   A = X
   X = Y
   Y = A
   OLDX = X
   OLDY = Y
   DO
    READ T$
    FOR T = 1 TO LEN(T$) STEP 2
     IF MID$(t$, t, 2) = "99" THEN EXIT LOOP
     IF MID$(T$, T, 2) <> "hg" THEN CALL BOX(Y, (OLDX + LEN(T$) / 2) - X + OLDX, Y + XDIFF, (OLDX + LEN(T$) / 2) - X + OLDX + YDIFF,( col(VAL(MID$(T$, T, 2)))))
     X = X + XDIFF
    NEXT
    Y = Y + YDIFF
    X = OLDX
   LOOP UNTIL RIGHT$(T$, 2) = "99"
  CASE 5
   A = X
   X = Y
   Y = A
   OLDX = X
   OLDY = Y
   DO
    READ T$
    FOR T = 1 TO LEN(T$) STEP 2
     IF MID$(t$, t, 2) = "99" THEN EXIT LOOP
     IF MID$(T$, T, 2) <> "hg" THEN CALL BOX(Y, X, Y + XDIFF, X + YDIFF, (col(VAL(MID$(T$, T, 2)))))
     X = X + XDIFF
    NEXT
    Y = Y + YDIFF
    X = OLDX
   LOOP UNTIL RIGHT$(T$, 2) = "99"
  CASE 6
   A = X
   X = Y
   Y = A
   OLDX = X
   OLDY = Y
   DO
    READ T$
    FOR T = 1 TO LEN(T$) STEP 2
     IF MID$(t$, t, 2) = "99" THEN EXIT LOOP
     IF MID$(T$, T, 2) <> "hg" THEN CALL BOX(OLDY - Y + OLDY, X, OLDY - Y + OLDY + XDIFF, X + YDIFF, (col(VAL(MID$(T$, T, 2)))))
     X = X + XDIFF
    NEXT
    Y = Y + YDIFF
    X = OLDX
   LOOP UNTIL RIGHT$(T$, 2) = "99"
  CASE 7
   A = X
   X = Y
   Y = A
   OLDX = X
   OLDY = Y
   DO
    READ T$
    FOR T = 1 TO LEN(T$) STEP 2
     IF MID$(t$, t, 2) = "99" THEN EXIT LOOP
     IF MID$(T$, T, 2) <> "hg" THEN CALL BOX(OLDY - Y + OLDY, (OLDX + LEN(T$) / 2) - X + OLDX, OLDY - Y + OLDY + XDIFF, (OLDX + LEN(T$) / 2) - X + OLDX + YDIFF, (col(VAL(MID$(T$, T, 2)))))
     X = X + XDIFF
    NEXT
    Y = Y + YDIFF
    X = OLDX
   LOOP UNTIL RIGHT$(T$, 2) = "99"
 END SELECT
END SUB

SUB SWAPCOLOUR (C1, C2)
 FOR Y = 0 TO YSCRMAX - 1
  FOR X = 0 TO XSCRMAX - 1
   IF GETPIXEL(X,Y) = C1 THEN CALL PUTPIXEL(X, Y, C2)
  NEXT
 NEXT
END SUB

SUB VGAINFO
 G$ = "You are in Mode " + HEX$(MSCREEN) + "." + STR$(XSCREEN) + "x" + LTRIM$(STR$(YSCREEN)) + " ," + STR$(CSCREEN) + " Colours! Granularit„t " + STR$(GRAN%) + ", Virtual Window :" + STR$(INT(XSCREEN / VGATX# + .5)) + "x"
 G$ = G$ + LTRIM$(STR$(INT(YSCREEN / VGATY# + .5)))
 CALL VGAPRINT(1, 1, 15, 0, G$, 2)
END SUB


SUB VGAINPUT (X1, Y1, c, C2, TEXT$, AUS$, FLAG)
 CALL VGAPRINT(X1, Y1, c, C2, TEXT$, FLAG OR 1)
 X = X1
 Y = Y1
 DO
  A$ = ""
  DO
   CALL VGAPRINT(X, Y, c, C2, "_", FLAG AND (255 - 1))
   A$ = INKEY$
   CALL VGAPRINT(X, Y, C2, C2, " ", (FLAG AND (255 - 1)) OR 2)
  LOOP WHILE A$ = ""
  IF A$ <> CHR$(13) THEN
   IF A$ = CHR$(8) THEN
    IF LEN(AUS$) > 0 THEN
     AUS$ = LEFT$(AUS$, LEN(AUS$) - 1)
     IF (FLAG AND 4) <> 0 THEN X = X - 1 ELSE X = X - CHARX
     CALL VGAPRINT(X, Y, C2, C2, " ", (FLAG AND (255 - 1)) OR 2)
    END IF
   ELSE
    AUS$ = AUS$ + A$
    CALL VGAPRINT(X, Y, c, C2, A$, FLAG OR 1)
   END IF
  END IF
 LOOP UNTIL A$ = CHR$(13)
 IF (FLAG AND 1) <> 0 THEN
  X1 = X
  Y1 = Y
 END IF
END SUB



SUB VGAPRINT (X1, Y1, c, C1, B$, FLAG)
'ZEICHEN OFFSET  Z*8+1
'LŽNGE 8 BYTE
'FLAGS       1 X/Y ERH™HEN    2 DEL BCKG       4TEXTKOORDINATEN
 OX = X1
 OY = Y1
 IF (FLAG AND 4) > 0 THEN
  X1 = (X1 - 1) * CHARX
  Y1 = (Y1 - 1) * CHARY
 END IF
 FOR N = 1 TO LEN(B$)
  P = ASC(MID$(B$, N, 1))
  CHAR$ = MID$(FONT$, P * 8 + 1, 8)
  FOR Y = 1 TO 8
   A$ = MID$(CHAR$, Y, 1)
   A = ASC(A$ + CHR$(0))
   A$ = RIGHT$("00000000" + LTRIM$(RTRIM$(BIN$(A))), 8)
   FOR X = 1 TO 8
    IF MID$(A$, X, 1) = "1" THEN
     CALL PUTPIXEL(X1 + X, Y1 + Y, c)
    ELSE
     IF (FLAG AND 2) > 0 THEN CALL PUTPIXEL(X1 + X, Y1 + Y, C1)
    END IF
   NEXT
  NEXT
  X1 = X1 + CHARX
  IF X1 > XSCMAX-CHARX THEN
   X1 = 0
   Y1 = Y1 + CHARY
   IF Y1 > YSCMAX-CHARY THEN EXIT SUB
  END IF
 NEXT
 IF (FLAG AND 1) > 0 THEN
  IF (FLAG AND 4) > 0 THEN
   X1 = INT(X1 / CHARX) + 1
   Y1 = INT(Y1 / CHARY) + 1
  END IF
 ELSE
  X1 = OX
  Y1 = OY
 END IF
END SUB

SUB VGASPRITE (X, Y, M)
 OLDX = X
 OLDY = Y
 DO
  READ T$
  FOR T = 1 TO LEN(T$) STEP 2
   IF MID$(t$, t, 2) = "99" THEN EXIT LOOP
   IF M = 1 THEN c = 0 ELSE c = VAL(MID$(T$, T, 2))
   IF MID$(T$, T, 2) <> "hg" THEN CALL PUTPIXEL(X, Y, c)
   X = X + 1
  NEXT
  Y = Y + 1
  X = OLDX
 LOOP UNTIL RIGHT$(T$, 2) = "99"
END SUB

SUB SETVGAVIEW(X1,Y1,X2,Y2)
 ANFX%=X1
 ANFY%=Y1
 ENDX%=X2
 ENDY%=Y2
 IF ANFX%>ENDX% THEN SWAP ANFX%,ENDX%
 IF ANFY%>ENDY% THEN SWAP ANFY%,ENDY%
END SUB

FUNCTION TEMPFILE$(T)
 FILE$=RIGHT$("00000000"+LTRIM$(RTRIM$(HEX$(T))),8)+".TMP"
 FILE$=ENVIRON$("TEMP")+"\"+FILE$
 TEMPFILE$=FILE$
END FUNCTION

SUB SAVESCREEN(X1,Y1,X2,Y2,FILE$)
 IF X2<X1 THEN SWAP X1,X2
 IF Y2<Y1 THEN SWAP Y1,Y2
 Z=FREEFILE
 OPEN "B",#Z,FILE$
  YA=Y2-Y1
  XA=X2-X1+1
  LX=XA MOD 256
  HX=INT(XA/256)
  LY=YA MOD 256
  HY=INT(YA/256)
  PUT$ #Z,"SHAD.VGA "+CHR$(LX)+CHR$(HX)+CHR$(LY)+CHR$(HY)
  FOR Y=Y1 TO Y2
   T$=""
   FOR X=X1 TO X2
    T$=T$+CHR$(GETPIXEL(X,Y))
   NEXT
   PUT$ #Z,T$
  NEXT
 CLOSE Z
END SUB

SUB LOADSCREEN(X1,Y1,FILE$)
 Z=FREEFILE
 OPEN "B",#Z,FILE$
  GET$ #Z,9,T$
  IF T$<>"SHAD.VGA " THEN
   BEEP
   CALL CLOSEVGA
   PRINT "KEINE SHADOW VGA FILE!"
   END
  END IF
  GET$ #Z,4,T$
  XA=ASC(MID$(T$,1,1))+256*ASC(MID$(T$,2,1))
  YA=ASC(MID$(T$,3,1))+256*ASC(MID$(T$,4,1))
  Y2=Y1+YA-1
  X2=X1+XA-1
  FOR Y=Y1 TO Y2
   GET$ #Z,XA,T$
   FOR X=X1 TO X2
    CALL PUTPIXEL(X,Y,ASC(MID$(T$,X-X1+1,1)+CHR$(0)))
   NEXT
  NEXT
 CLOSE Z
END SUB

SUB DELSCREEN(M)
 DIM XW AS WORD,YW AS WORD
 XW=XSCMAX
 YW=YSCMAX
 CALL SETVGAWINDOW(XSCREEN,YSCREEN)
 SELECT CASE M
  CASE 0
   FOR Y=0 TO YSCREEN STEP 2
    CALL LINEDRAW(0,Y,XSCREEN,Y,0)
   NEXT
   Y=YSCREEN-1
   DO
    CALL LINEDRAW(0,Y,XSCREEN,Y,0)
    Y=Y-2
   LOOP UNTIL Y<0
  CASE 1
   Y=YSCREEN-1
   DO
    CALL LINEDRAW(0,Y,XSCREEN,Y,0)
    Y=Y-2
   LOOP UNTIL Y<0
   FOR Y=0 TO YSCREEN STEP 2
    CALL LINEDRAW(0,Y,XSCREEN,Y,0)
   NEXT
  CASE 2
   FOR X=0 TO XSCREEN STEP 2
    CALL LINEDRAW(X,0,X,YSCREEN,0)
   NEXT
   X=XSCREEN-1
   DO
    CALL LINEDRAW(X,0,X,YSCREEN,0)
    X=X-2
   LOOP UNTIL X<0
  CASE 3
   X=XSCREEN-1
   DO
    CALL LINEDRAW(X,0,X,YSCREEN,0)
    X=X-2
   LOOP UNTIL X<0
   FOR X=0 TO XSCREEN STEP 2
    CALL LINEDRAW(X,0,X,YSCREEN,0)
   NEXT
  CASE 4
   FOR T=0 TO 63
    FOR N=0 TO 255
     OUT &H3C7,N
     R=INP(&H3C9)-1
     G=INP(&H3C9)-1
     B=INP(&H3C9)-1
     IF R<0 THEN R=0
     IF G<0 THEN G=0
     IF B<0 THEN B=0
     OUT &H3C8,N
     OUT &H3C9,R
     OUT &H3C9,G
     OUT &H3C9,B
    NEXT
   NEXT
  CASE 5
   FOR Y=0 TO YSCREEN
    CALL LINEDRAW(0,Y,XSCREEN,Y,0)
   NEXT
  CASE 6
   Y=YSCREEN
   DO
    CALL LINEDRAW(0,Y,XSCREEN,Y,0)
    Y=Y-1
   LOOP UNTIL Y<0
  CASE 7
   FOR X=0 TO XSCREEN
    CALL LINEDRAW(X,0,X,YSCREEN,0)
   NEXT
  CASE 8
   X=XSCREEN
   DO
    CALL LINEDRAW(X,0,X,YSCREEN,0)
    X=X-1
   LOOP UNTIL X<0
  CASE 9
   DEF SEG=&HA000
   IF MSCREEN=13 THEN
    POKE$ 0,STRING$(32750,0)
    POKE$ 32750,STRING$(32750,0)
   ELSE
    FOR WIN=0 TO (XSCREEN*YSCREEN)\65536+1
     CALL SETVESAWINDOW(WIN)
     FOR T=0 TO 3
      POKE$ T*16384,STRING$(16384,0)
     NEXT
     'POKE$ 0,STRING$(32750,0)
     'POKE$ 32750,STRING$(32750,0)
     'POKE$ 65500,STRING$(36,0)
    NEXT
   END IF
   CALL SETVESAWINDOW((VESAWINDOW))
   DEF SEG
 END SELECT
 SETVGAWINDOW XW,YW
END SUB

SUB WAITHRETRACE
 WAIT &H3DA,1
 WAIT &H3DA,255,9
' DO WHILE (INP(&H3DA) AND 1) <> 0
' LOOP
' DO WHILE (INP(&H3DA) AND 9) <> 1
' LOOP
END SUB

SUB WAITVRETRACE
 'WAIT &H3DA,8
 DO WHILE (INP(&H3DA) AND 8) <> 0
 LOOP
 DO WHILE (INP(&H3DA) AND 8) = 0
 LOOP

END SUB

SUB SETVESAWINDOW(BYVAL WIN AS WORD)
 !MOV AX,&H4F05
 !XOR BX,BX
 !MOV BL,CWIN
 !MOV DX,WIN
 !INT &H10
END SUB

SUB TAKEEMS(S,H)
 REG 1,&H4300
 REG 2,INT(S/16384)+1
 CALL INTERRUPT &H67
 H=REG(4)
 REG 1,&H4100
 CALL INTERRUPT &H67
 PFRAME%=REG(2)
END SUB

SUB EMSBYTE(PAGE,POFF,W,H)
 IF H=OLDEMSHANDLE% THEN
  IF PAGE<>OLDEMSPAGE% THEN
   REG 1,&H4800
   REG 4,OLDEMSHANDLE%
   CALL INTERRUPT &H67
   REG 1,&H4400
   REG 2,PAGE
   REG 4,H
   CALL INTERRUPT &H67
  END IF
 ELSE
  REG 1,&H4800
  REG 4,OLDEMSHANDLE%
  CALL INTERRUPT &H67
  REG 1,&H4400
  REG 2,PAGE
  REG 4,H
  CALL INTERRUPT &H67
 END IF
 OLDEMSPAGE%=PAGE
 OLDEMSHANDLE%=H
 W%=W
 POFF%=POFF
 IF W=-1 THEN
  !PUSH ES
  !MOV ES,PFRAME%
  !MOV BX,POFF%
  !MOV AX,W%
  !MOV AL,ES:[BX]
  !MOV AH,0
  !MOV W%,AX
  !POP ES
  W=W%
 ELSE
  !PUSH ES
  !MOV ES,PFRAME%
  !MOV BX,POFF%
  !MOV AX,W%
  !MOV ES:[BX],AL
  !POP ES
 END IF
END SUB

SUB PUTEMSSTRING(S,O,T$,H)
 T&&=S*16+O
 IF T&&<0 THEN T&&=T&&+2^20+2^16
 PAGE=INT(T&&/16384)
 POFF=T&& MOD 16384
 IF H=OLDEMSHANDLE% THEN
  IF PAGE<>OLDEMSPAGE% THEN
   REG 1,&H4800
   REG 4,OLDEMSHANDLE%
   CALL INTERRUPT &H67
   REG 1,&H4400
   REG 2,PAGE
   REG 4,H
   CALL INTERRUPT &H67
  END IF
 ELSE
  REG 1,&H4800
  REG 4,OLDEMSHANDLE%
  CALL INTERRUPT &H67
  REG 1,&H4400
  REG 2,PAGE
  REG 4,H
  CALL INTERRUPT &H67
 END IF
 OLDEMSPAGE%=PAGE
 OLDEMSHANDLE%=H
 DEF SEG=PFRAME%
 POKE$ POFF,T$
END SUB

FUNCTION GETEMSSTRING$(S,O,L,H)
 T&&=S*16+O
 IF T&&<0 THEN T&&=T&&+2^20+2^16
 PAGE=INT(T&&/16384)
 POFF=T&& MOD 16384
 IF H=OLDEMSHANDLE% THEN
  IF PAGE<>OLDEMSPAGE% THEN
   REG 1,&H4800
   REG 4,OLDEMSHANDLE%
   CALL INTERRUPT &H67
   REG 1,&H4400
   REG 2,PAGE
   REG 4,H
   CALL INTERRUPT &H67
  END IF
 ELSE
  REG 1,&H4800
  REG 4,OLDEMSHANDLE%
  CALL INTERRUPT &H67
  REG 1,&H4400
  REG 2,PAGE
  REG 4,H
  CALL INTERRUPT &H67
 END IF
 OLDEMSPAGE%=PAGE
 OLDEMSHANDLE%=H
 DEF SEG=PFRAME%
 GETEMSSTRING$=PEEK$(POFF,L)
END FUNCTION

SUB CLOSEEMS(H)
 REG 1,&H4500
 REG 4,H
 CALL INTERRUPT &H67
END SUB

SUB PUTEMSBYTE(SEGM,OFFS,B,H)
 T&&=SEGM*16+OFFS
 IF T&&<0 THEN T&&=T&&+2^20+2^16
 PAGE=INT(T&&/16384)
 POFF=T&& MOD 16384
 CALL EMSBYTE(PAGE,POFF,B,H)
END SUB

FUNCTION GETEMSBYTE(SEGM,OFFS,H)
 B=-1
 T&&=SEGM*16+OFFS
 IF T&&<0 THEN T&&=T&&+2^20+2^16
 PAGE=INT(T&&/16384)
 POFF=T&& MOD 16384
 CALL EMSBYTE(PAGE,POFF,B,H)
 GETEMSBYTE=B
END FUNCTION

SUB SEG2EMS(SEGM,OFFS,M,SEG2,OFF2)
 IF M<0 THEN
  SEG2=SEGM
  OFF2=OFFS
 ELSE
  T&&=SEGM*16+OFFS
  IF T&&<0 THEN T&&=T&&+2^20+2^16
  SEG2=INT(T&&/16384)
  OFF2=T&& MOD 16384
 END IF
END SUB

SUB VESA2EMS(WIN,OFFS,SEG2,OFF2)
 T&&=WIN*65536+OFFS
 IF T&&<0 THEN T&&=T&&+2^20+2^16
 SEG2=INT(T&&/16384)
 OFF2=T&& MOD 16384
END SUB

SUB VESAEMSOFF(WIN,OFFS,T&&)
 T&&=WIN*65536+OFFS
 IF T&&<0 THEN T&&=T&&+2^20+2^16
END SUB

FUNCTION WIN2SEG(WIN)
 WIN2SEG=WIN*&H1000
END FUNCTION

SUB SAVEEMSSCREEN(X1,Y1,X2,Y2,H)
 IF X2<X1 THEN SWAP X1,X2
 IF Y2<Y1 THEN SWAP Y1,Y2
 YA=Y2-Y1+1
 XA=X2-X1+1
 LX=XA MOD 256
 HX=INT(XA/256)
 LY=YA MOD 256
 HY=INT(YA/256)
 CALL PUTEMSBYTE(&H0000,&H0000,LX,H)
 CALL PUTEMSBYTE(&H0000,&H0001,HX,H)
 CALL PUTEMSBYTE(&H0000,&H0002,LY,H)
 CALL PUTEMSBYTE(&H0000,&H0003,HY,H)
 T=0
 FOR Y=Y1 TO Y2
  FOR X=X1 TO X2
   CALL PUTEMSBYTE(&H0000,&H0004+T,GETPIXEL(X,Y),H)
   T=T+1
  NEXT
 NEXT
END SUB

SUB LOADEMSSCREEN(X1,Y1,H)
 XA=GETEMSBYTE(&H0000,&H0000,H)+256*GETEMSBYTE(&H0000,&H0001,H)
 YA=GETEMSBYTE(&H0000,&H0002,H)+256*GETEMSBYTE(&H0000,&H0003,H)
 Y2=Y1+YA-1
 X2=X1+XA-1
 T=0
 FOR Y=Y1 TO Y2
  FOR X=X1 TO X2
   CALL PUTPIXEL(X,Y,GETEMSBYTE(&H0000,&H0004+T,H))
   T=T+1
  NEXT
 NEXT
END SUB

SUB WRITEEMS
 REG 1,&H4800
 REG 4,OLDEMSHANDLE%
 CALL INTERRUPT &H67
END SUB

SUB MEMCOPY(SEGM1,OFFM1,M1,SEGM2,OFFM2,M2,S)
 CALL SEG2EMS(SEGM1,OFFM1,M1,SEG1,OFF1)
 CALL SEG2EMS(SEGM2,OFFM2,M2,SEG2,OFF2)
 IF SEG1<0 THEN SEG1=SEG1+65536
 IF SEG2<0 THEN SEG2=SEG2+65536
 IF OFF1<0 THEN OFF1=OFF1+65536
 IF OFF2<0 THEN OFF2=OFF2+65536
 L=S MOD 65536
 H=INT(S/65536)
 LL=L MOD 256
 HL=INT(L/256)
 LH=H MOD 256
 HH=INT(H/256)
 T$=CHR$(LL)+CHR$(HL)+CHR$(LH)+CHR$(HH)
 IF M1<0 THEN T$=T$+CHR$(0)+CHR$(0)+CHR$(0) ELSE T$=T$+CHR$(1)+CHR$(M1 MOD 256)+CHR$(INT(M1/256))
 L=OFF1 MOD 256
 H=INT(OFF1/256)
 T$=T$+CHR$(L)+CHR$(H)
 L=SEG1 MOD 256
 H=INT(SEG1/256)
 T$=T$+CHR$(L)+CHR$(H)
 IF M2<0 THEN T$=T$+CHR$(0)+CHR$(0)+CHR$(0) ELSE T$=T$+CHR$(1)+CHR$(M2 MOD 256)+CHR$(INT(M2/256))
 L=OFF2 MOD 256
 H=INT(OFF2/256)
 T$=T$+CHR$(L)+CHR$(H)
 L=SEG2 MOD 256
 H=INT(SEG2/256)
 T$=T$+CHR$(L)+CHR$(H)
 REG 1,&H5700
 REG 5,STRPTR(T$)
 REG 8,STRSEG(T$)
 CALL INTERRUPT &H67
END SUB

SUB MEMSWAP(SEGM1,OFFM1,M1,SEGM2,OFFM2,M2,S)
 CALL SEG2EMS(SEGM1,OFFM1,M1,SEG1,OFF1)
 CALL SEG2EMS(SEGM2,OFFM2,M2,SEG2,OFF2)
 IF SEG1<0 THEN SEG1=SEG1+65536
 IF SEG2<0 THEN SEG2=SEG2+65536
 IF OFF1<0 THEN OFF1=OFF1+65536
 IF OFF2<0 THEN OFF2=OFF2+65536
 L=S MOD 65536
 H=INT(S/65536)
 LL=L MOD 256
 HL=INT(L/256)
 LH=H MOD 256
 HH=INT(H/256)
 T$=CHR$(LL)+CHR$(HL)+CHR$(LH)+CHR$(HH)
 IF M1<0 THEN T$=T$+CHR$(0)+CHR$(0)+CHR$(0) ELSE T$=T$+CHR$(1)+CHR$(M1 MOD 256)+CHR$(INT(M1/256))
 L=OFF1 MOD 256
 H=INT(OFF1/256)
 T$=T$+CHR$(L)+CHR$(H)
 L=SEG1 MOD 256
 H=INT(SEG1/256)
 T$=T$+CHR$(L)+CHR$(H)
 IF M2<0 THEN T$=T$+CHR$(0)+CHR$(0)+CHR$(0) ELSE T$=T$+CHR$(1)+CHR$(M2 MOD 256)+CHR$(INT(M2/256))
 L=OFF2 MOD 256
 H=INT(OFF2/256)
 T$=T$+CHR$(L)+CHR$(H)
 L=SEG2 MOD 256
 H=INT(SEG2/256)
 T$=T$+CHR$(L)+CHR$(H)
 REG 1,&H5701
 REG 5,STRPTR(T$)
 REG 8,STRSEG(T$)
 CALL INTERRUPT &H67
END SUB

SUB VESAEMSCOPY(H)
 IF MSCREEN<>13 THEN
  FOR NEWWIN&=0 TO INT(BPLINE*YSCREEN/65536)+1
   WIN = newwin& * (64 / GRAN%)
   CALL SETVESAWINDOW(WIN)
   SEG1=WIN2SEG(CSNG(NEWWIN&))
   IF SEG1<0 THEN SEG1=SEG1+65536
   CALL MEMCOPY(SEG1,&H0000,H,&HA000,&H0000,-1,65536)
  NEXT
 ELSE
  CALL MEMCOPY(&H0000,&H0000,H,&HA000,&H0000,-1,65536)
 END IF
 call setvesawindow(0)
 VESAWINDOW =0
 VESAX% = 0
 VESAY% = 0
 VESAOFF& = 0
END SUB

SUB EMSVESACOPY(H)
 IF MSCREEN<>13 THEN
  FOR WIN=0 TO INT(BPLINE*YSCREEN/65536)+1
   CALL SETVESAWINDOW(WIN*64/GRAN%)
   SEG1=WIN2SEG(WIN)
   IF SEG1<0 THEN SEG1=SEG1+65536
   CALL MEMSWAP(SEG1,&H0000,H,&HA000,&H0000,-1,65536)
   CALL MEMCOPY(SEG1,&H0000,H,&HA000,&H0000,-1,65536)
  NEXT
 ELSE
  CALL MEMSWAP(&H0000,&H0000,H,&HA000,&H0000,-1,65536)
  CALL MEMCOPY(&H0000,&H0000,H,&HA000,&H0000,-1,65536)
 END IF
 call setvesawindow(0)
 VESAWINDOW =0
 VESAX% = 0
 VESAY% = 0
 VESAOFF& = 0
END SUB

SUB VESAEMSSWAP(H)
 IF MSCREEN<>13 THEN
  FOR NEWWIN&=0 TO INT(BPLINE*YSCREEN/65536)+1
   SELECT CASE GRAN%
    CASE 1
     WIN = newwin& * 64
    CASE 2
     WIN = newwin& * 32
    CASE 4
     WIN = newwin& * 16
    CASE 8
     WIN = newwin& * 8
    CASE 16
     WIN = newwin& * 4
   CASE 32
     WIN = newwin& * 2
    CASE 64
     WIN = newwin&
    CASE ELSE
     WIN = newwin& * (64 / GRAN%)
   END SELECT
   CALL SETVESAWINDOW(WIN)
   SEG1=WIN2SEG(CSNG(NEWWIN&))
   IF SEG1<0 THEN SEG1=SEG1+65536
   CALL MEMSWAP(SEG1,&H0000,H,&HA000,&H0000,-1,65536)
  NEXT
 ELSE
  CALL MEMSWAP(&H0000,&H0000,H,&HA000,&H0000,-1,65536)
 END IF
 call setvesawindow(0)
 VESAWINDOW = 0
 VESAX% = 0
 VESAY% = 0
 VESAOFF& = 0
END SUB

FUNCTION GETBMPPIXEL(X,Y)
 IF BMPBPP%=8 THEN
  SEEK BMPHANDLE,BMPOFF+X+BMPXSCREEN*(BMPYSCREEN-Y-1)
  GET$ #BMPHANDLE,1,C$
  GETBMPPIXEL=ASC(C$)
 END IF
END FUNCTION

SUB PUTBMPPIXEL(X,Y,C)
 IF BMPBPP%=8 THEN
  SEEK BMPHANDLE,BMPOFF+X+BMPXSCREEN*(BMPYSCREEN-Y-1)
  PUT$ #BMPHANDLE,CHR$(C)
 END IF
END SUB

SUB INITBMP(F$)
 Z=FREEFILE
 OPEN F$ FOR BINARY AS #Z
  SEEK Z, &HA
  GET$ Z,4,A$
  BMPOFF = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  SEEK Z, &H12
  GET$ Z,4,A$
  BMPXSCREEN = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  GET$ Z,4,A$
  BMPYSCREEN = (ASC(MID$(A$, 1, 1)) + 256 * ASC(MID$(A$, 2, 1))) + 65536 * (ASC(MID$(A$, 3, 1)) + 256 * ASC(MID$(A$, 4, 1)))
  SEEK Z, &H1C
  GET$ Z,2,T$
  BMPBPP%=(ASC(LEFT$(T$,1))+256*ASC(RIGHT$(T$,1)))
  BMPCSCREEN=2^BMPBPP%
  BMPHANDLE=Z
  BMPVGATX#=1
  BMPVGATY#=1
END SUB

SUB READBMPPAL(PAL())
 SEEK BMPHANDLE,&H36
 FOR T% = 0 TO BMPCSCREEN-1
  GET$ BMPHANDLE,1,B$
  GET$ BMPHANDLE,1,G$
  GET$ BMPHANDLE,1,R$
  GET$ BMPHANDLE,1,I$
  PAL(T%,0)=ASC(R$)
  PAL(T%,1)=ASC(G$)
  PAL(T%,2)=ASC(B$)
  PAL(T%,3)=ASC(I$)
 NEXT
END SUB

SUB WRITEBMPPAL(PAL())
 SEEK BMPHANDLE,&H36
 FOR T% = 0 TO BMPCSCREEN-1
  PUT$ BMPHANDLE,CHR$(PAL(T%,2))
  PUT$ BMPHANDLE,CHR$(PAL(T%,1))
  PUT$ BMPHANDLE,CHR$(PAL(T%,0))
  PUT$ BMPHANDLE,CHR$(PAL(T%,3))
 NEXT
END SUB

SUB BMPPRINT (X1, Y1, c, C1, B$, FLAG)
'ZEICHEN OFFSET  Z*8+1
'LŽNGE 8 BYTE
'FLAGS       1 X/Y ERH™HEN    2 DEL BCKG       4TEXTKOORDINATEN
 OX = X1
 OY = Y1
 IF (FLAG AND 4) > 0 THEN
  X1 = (X1 - 1) * CHARX
  Y1 = (Y1 - 1) * CHARY
 END IF
 FOR N = 1 TO LEN(B$)
  P = ASC(MID$(B$, N, 1))
  CHAR$ = MID$(FONT$, P * 8 + 1, 8)
  FOR Y = 1 TO 8
   A$ = MID$(CHAR$, Y, 1)
   A = ASC(A$ + CHR$(0))
   A$ = RIGHT$("00000000" + LTRIM$(RTRIM$(BIN$(A))), 8)
   FOR X = 1 TO 8
    IF MID$(A$, X, 1) = "1" THEN
     CALL PUTBMPPIXEL(X1 + X, Y1 + Y, c)
    ELSE
     IF (FLAG AND 2) > 0 THEN CALL PUTBMPPIXEL(X1 + X, Y1 + Y, C1)
    END IF
   NEXT
  NEXT
  X1 = X1 + CHARX
  IF X1 > INT(BMPXSCREEN / BMPVGATX# + .5)-CHARX THEN
   X1 = 0
   Y1 = Y1 + CHARY
   IF Y1 > INT(BMPYSCREEN / BMPVGATY# + .5)-CHARY THEN EXIT SUB
  END IF
 NEXT
 IF (FLAG AND 1) > 0 THEN
  IF (FLAG AND 4) > 0 THEN
   X1 = INT(X1 / CHARX) + 1
   Y1 = INT(Y1 / CHARY) + 1
  END IF
 ELSE
  X1 = OX
  Y1 = OY
 END IF
END SUB
