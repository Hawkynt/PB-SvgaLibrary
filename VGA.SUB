' =============================================================================
' VGA.SUB - Standard VGA Graphics Functions  
' =============================================================================
' Contains standard VGA mode (Mode 13h and others) graphics functions
' Optimized for direct linear memory access without banking
' =============================================================================

' =============================================================================
' VGA Drawing Primitives - Optimized for Mode 13h and direct VGA access
' =============================================================================

' =============================================================================
' Set pixel in standard VGA mode (Mode 13h)
' Parameters:
'   X, Y - Pixel coordinates (BYVAL)
'   Color - Pixel color value (BYVAL)
' Returns: Nothing
' Note: Optimized for Mode 13h 320x200x256 linear memory layout
' =============================================================================
SUB Vga_PutPixel(BYVAL x AS WORD, BYVAL y AS WORD, BYVAL color AS BYTE)
    ' Ultra-fast assembly optimized pixel write for Mode 13h
    !PUSH ES

    ' Hopefully this is loaded in parallel
    !MOV BX, y               ; Start: Y → BX
    !MOV AX, &HA000          ; Parallel: preload A000h in AX

    ' While copying DX, we may as well start fetching from memory again
    !MOV DX, BX              ; Copy Y to DX for parallel shift path
    !MOV CX, x               ; In parallel: X → CX

    ' Now we sadly block the shifter two times but we try get the mov in parallel
    !SHL BX, 8               ; BX = Y * 256
    !MOV ES, AX              ; Now set ES (last use of AX)

    !SHL DX, 6               ; DX = Y * 64
    !MOV AL, color           ; In parallel: load color to AL
    
    ' now here's a data dependency that keeps us waiting
    !ADD BX, DX              ; BX = Y * 320
    !ADD BX, CX              ; Final offset

    ' at least we already got ES and CL setup so we no longer waste cycles
    !MOV ES:[BX], AL         ; Store pixel

    !POP ES
END SUB

' =============================================================================
' Get pixel from standard VGA mode
' Parameters:
'   X, Y - Pixel coordinates (BYVAL)
' Returns: Pixel color value
' =============================================================================
FUNCTION Vga_GetPixel(BYVAL x AS WORD, BYVAL y AS WORD) AS BYTE
    ' Ultra-fast assembly optimized pixel read for Mode 13h
    DIM PixelValue AS BYTE
        
    !PUSH ES

    !MOV BX, y               ; BX = Y
    !MOV AX, &HA000          ; Prepare segment early
    !MOV DX, BX              ; DX = Y (copy for parallel shift path)
    !MOV CX, x               ; CX = X

    !SHL BX, 8               ; BX = Y * 256
    !MOV ES, AX              ; Now set ES = A000h

    !SHL DX, 6               ; DX = Y * 64
                            ; interleaved: no pressure here

    !ADD BX, DX              ; BX = Y * 320
    !ADD BX, CX              ; BX = Y * 320 + X

    !MOV AL, ES:[BX]         ; Read pixel
    !MOV PixelValue, AL      ; Store result

    !POP ES
    
    Vga_GetPixel = PixelValue
END FUNCTION

' =============================================================================
' Draw horizontal line in VGA mode (highly optimized)
' Parameters:
'   X1, X2 - Start and end X coordinates (BYVAL)
'   Y - Y coordinate (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' Note: Uses fast assembly for maximum speed
' =============================================================================
SUB Vga_HLine(BYVAL x1 AS WORD, BYVAL x2 AS WORD, BYVAL y AS WORD, BYVAL color AS BYTE)
    DIM StartOffset AS WORD, LineLength AS WORD
    DIM ColorWord AS WORD, ColorDWord AS LONG
    
    ' Ensure X1 <= X2
    IF x1 > x2 THEN SWAP x1, x2
    
    StartOffset = y * 320 + x1
    LineLength = x2 - x1 + 1
    
    ' Prepare color patterns for faster filling
    ColorWord = (color * 256) + color      ' AABBH pattern
    ColorDWord = (ColorWord * 65536&) + ColorWord  ' AABBAABBH pattern
    
    ' Ultra-optimized assembly using REP STOSW string instruction
    !PUSH ES
    !PUSH DI
    !MOV AX, &HA000
    !MOV ES, AX
    !MOV DI, StartOffset
    !MOV CX, LineLength
    !CLD                    ; Clear direction flag (forward)
    
    ' Handle odd starting pixel if not word-aligned
    !TEST DI, 1             ; Check if starting address is odd
    !JZ VGAHLineWordAlign   ; Jump if even (word-aligned)
    !MOV AL, color
    !STOSB                  ; Store AL to ES:[DI], increment DI
    !DEC CX
    !JZ VGAHLineDone        ; Done if only one pixel
    
    VGAHLineWordAlign:
    ' Use REP STOSW for maximum speed (2 pixels at once)
    !MOV DX, CX
    !SHR CX, 1              ; Divide by 2 for word count
    !JZ VGAHLineRemainder   ; Jump if less than 2 pixels left
    !MOV AX, ColorWord      ; Load word pattern
    !REP STOSW              ; Ultra-fast: store AX to ES:[DI], repeat CX times
    
    VGAHLineRemainder:
    ' Handle remaining odd pixel
    !TEST DX, 1             ; Check if original length was odd
    !JZ VGAHLineDone        ; Jump if no remainder
    !MOV AL, color
    !STOSB                  ; Store final pixel
    
    VGAHLineDone:
    !POP DI
    !POP ES
END SUB

' =============================================================================
' Draw vertical line in VGA mode (ultra-optimized)
' Parameters:
'   X - X coordinate (BYVAL)
'   Y1, Y2 - Start and end Y coordinates (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' Note: Uses direct memory calculation with no per-pixel overhead
' =============================================================================
SUB Vga_VLine(BYVAL x AS WORD, BYVAL y1 AS WORD, BYVAL y2 AS WORD, BYVAL color AS BYTE)
    DIM StartOffset AS WORD, LineLength AS WORD
    
    ' Ensure Y1 <= Y2
    IF y1 > y2 THEN SWAP y1, y2
    
    StartOffset = y1 * 320 + x
    LineLength = y2 - y1 + 1
    
    ' Ultra-optimized vertical line using assembly - no per-pixel calculations
    !PUSH ES
    !MOV AX, &HA000
    !MOV ES, AX
    !MOV BX, StartOffset      ; Starting memory address
    !MOV AL, color           ; Pixel color
    !MOV DX, 320             ; Bytes per scanline (constant)
    !MOV CX, LineLength      ; Number of pixels to draw
    
    ' Optimized loop with minimal overhead
    VGAVLineOptimized:
    !MOV ES:[BX], AL         ; Set pixel
    !ADD BX, DX              ; Move to next scanline (320 bytes down)
    !LOOP VGAVLineOptimized  ; Decrement CX and loop if not zero
    
    !POP ES
END SUB

' =============================================================================
' Draw line between two points in VGA mode
' Parameters:
'   X1, Y1 - Starting point coordinates (BYVAL)
'   X2, Y2 - Ending point coordinates (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' Note: Uses optimized routines for horizontal/vertical lines
' =============================================================================
SUB Vga_LineDraw(BYVAL x1 AS WORD, BYVAL y1 AS WORD, BYVAL x2 AS WORD, BYVAL y2 AS WORD, BYVAL color AS BYTE)
    ' Check for horizontal line
    IF y1 = y2 THEN
        CALL Vga_HLine(x1, x2, y1, color)
        EXIT SUB
    END IF
    
    ' Check for vertical line
    IF x1 = x2 THEN
        CALL Vga_VLine(x1, y1, y2, color)
        EXIT SUB
    END IF
    
    ' Diagonal line - use Bresenham's algorithm
    DIM DeltaX AS INTEGER, DeltaY AS INTEGER, StepX AS INTEGER, StepY AS INTEGER
    DIM ErrorTerm AS INTEGER, CurrentX AS WORD, CurrentY AS WORD
    
    ' Calculate deltas and step directions
    DeltaX = ABS(x2 - x1)
    DeltaY = ABS(y2 - y1)
    
    IF x1 < x2 THEN StepX = 1 ELSE StepX = -1
    IF y1 < y2 THEN StepY = 1 ELSE StepY = -1
    
    ' Initialize error term
    ErrorTerm = DeltaX - DeltaY
    
    ' Set starting position
    CurrentX = x1
    CurrentY = y1
    
    ' Draw line using Bresenham's algorithm
    DO
        CALL Vga_PutPixel(CurrentX, CurrentY, color)
        
        ' Check if we've reached the end point
        IF CurrentX = x2 AND CurrentY = y2 THEN EXIT DO
        
        ' Calculate next point
        DIM Error2 AS INTEGER
        Error2 = ErrorTerm * 2
        
        IF Error2 > -DeltaY THEN
            ErrorTerm = ErrorTerm - DeltaY
            CurrentX = CurrentX + StepX
        END IF
        
        IF Error2 < DeltaX THEN
            ErrorTerm = ErrorTerm + DeltaX
            CurrentY = CurrentY + StepY
        END IF
    LOOP
END SUB

' =============================================================================
' Draw filled rectangle in VGA mode
' Parameters:
'   X1, Y1 - Top-left corner (BYVAL)
'   X2, Y2 - Bottom-right corner (BYVAL)
'   Color - Fill color (BYVAL)
' Returns: Nothing
' Note: Uses optimized horizontal line fills
' =============================================================================
SUB Vga_FillRect(BYVAL x1 AS WORD, BYVAL y1 AS WORD, BYVAL x2 AS WORD, BYVAL y2 AS WORD, BYVAL color AS BYTE)
    DIM ScanLine AS WORD
    
    ' Ensure coordinates are ordered
    IF x1 > x2 THEN SWAP x1, x2
    IF y1 > y2 THEN SWAP y1, y2
    
    ' Fill rectangle using horizontal lines
    FOR ScanLine = y1 TO y2
        CALL Vga_HLine(x1, x2, ScanLine, color)
    NEXT ScanLine
END SUB

' =============================================================================
' Draw rectangle outline in VGA mode
' Parameters:
'   X1, Y1 - Top-left corner (BYVAL)
'   X2, Y2 - Bottom-right corner (BYVAL)
'   Color - Border color (BYVAL)
' Returns: Nothing
' =============================================================================
SUB Vga_DrawRect(BYVAL x1 AS WORD, BYVAL y1 AS WORD, BYVAL x2 AS WORD, BYVAL y2 AS WORD, BYVAL color AS BYTE)
    ' Ensure coordinates are ordered
    IF x1 > x2 THEN SWAP x1, x2
    IF y1 > y2 THEN SWAP y1, y2
    
    ' Draw four sides
    CALL Vga_HLine(x1, x2, y1, color)  ' Top
    CALL Vga_HLine(x1, x2, y2, color)  ' Bottom
    CALL Vga_VLine(x1, y1, y2, color)  ' Left
    CALL Vga_VLine(x2, y1, y2, color)  ' Right
END SUB

' =============================================================================
' Draw circle in VGA mode using midpoint algorithm
' Parameters:
'   CenterX, CenterY - Center coordinates (BYVAL)
'   Radius - Circle radius (BYVAL)
'   Color - Circle color (BYVAL)
' Returns: Nothing
' Note: Standard midpoint circle algorithm
' =============================================================================
SUB Vga_DrawCircle(BYVAL centerX AS WORD, BYVAL centerY AS WORD, BYVAL radius AS WORD, BYVAL color AS BYTE)
    DIM X AS INTEGER, Y AS INTEGER, DecisionParam AS INTEGER
    
    X = 0
    Y = radius
    DecisionParam = 1 - radius
    
    ' Draw initial points
    CALL Vga_PutPixel(centerX, centerY + radius, color)
    CALL Vga_PutPixel(centerX, centerY - radius, color)
    CALL Vga_PutPixel(centerX + radius, centerY, color)
    CALL Vga_PutPixel(centerX - radius, centerY, color)
    
    ' Draw circle using midpoint algorithm
    DO WHILE X < Y
        X = X + 1
        
        IF DecisionParam < 0 THEN
            DecisionParam = DecisionParam + 2 * X + 1
        ELSE
            Y = Y - 1
            DecisionParam = DecisionParam + 2 * (X - Y) + 1
        END IF
        
        ' Draw 8 symmetric points
        CALL Vga_PutPixel(centerX + X, centerY + Y, color)
        CALL Vga_PutPixel(centerX - X, centerY + Y, color)
        CALL Vga_PutPixel(centerX + X, centerY - Y, color)
        CALL Vga_PutPixel(centerX - X, centerY - Y, color)
        CALL Vga_PutPixel(centerX + Y, centerY + X, color)
        CALL Vga_PutPixel(centerX - Y, centerY + X, color)
        CALL Vga_PutPixel(centerX + Y, centerY - X, color)
        CALL Vga_PutPixel(centerX - Y, centerY - X, color)
    LOOP
END SUB

' =============================================================================
' Draw filled circle in VGA mode
' Parameters:
'   CenterX, CenterY - Center coordinates (BYVAL)
'   Radius - Circle radius (BYVAL)
'   Color - Fill color (BYVAL)
' Returns: Nothing
' Note: Uses horizontal line fills for efficiency
' =============================================================================
SUB Vga_FillCircle(BYVAL centerX AS WORD, BYVAL centerY AS WORD, BYVAL radius AS WORD, BYVAL color AS BYTE)
    DIM X AS INTEGER, Y AS INTEGER, DecisionParam AS INTEGER
    DIM PrevY AS INTEGER
    
    X = 0
    Y = radius
    DecisionParam = 1 - radius
    PrevY = Y
    
    ' Draw initial horizontal line
    CALL Vga_HLine(centerX - radius, centerX + radius, centerY, color)
    
    ' Fill circle using horizontal lines
    DO WHILE X < Y
        X = X + 1
        
        IF DecisionParam < 0 THEN
            DecisionParam = DecisionParam + 2 * X + 1
        ELSE
            ' Y changed, draw horizontal lines for previous Y
            IF Y <> PrevY THEN
                CALL Vga_HLine(centerX - X + 1, centerX + X - 1, centerY + PrevY, color)
                CALL Vga_HLine(centerX - X + 1, centerX + X - 1, centerY - PrevY, color)
                PrevY = Y
            END IF
            
            Y = Y - 1
            DecisionParam = DecisionParam + 2 * (X - Y) + 1
        END IF
        
        ' Draw horizontal lines for current positions
        CALL Vga_HLine(centerX - Y, centerX + Y, centerY + X, color)
        CALL Vga_HLine(centerX - Y, centerX + Y, centerY - X, color)
    LOOP
    
    ' Draw final lines if Y changed
    IF Y <> PrevY THEN
        CALL Vga_HLine(centerX - X, centerX + X, centerY + Y, color)
        CALL Vga_HLine(centerX - X, centerX + X, centerY - Y, color)
    END IF
END SUB

' =============================================================================
' Clear VGA screen to specified color (Mode 13h)
' Parameters:
'   Color - Fill color (BYVAL)
' Returns: Nothing
' Note: Extremely fast for Mode 13h using assembly
' =============================================================================
SUB Vga_ClearScreen(BYVAL color AS BYTE)
    ' Use ultra-optimized ClearVideoMemory for maximum speed
    ' This function uses unrolled loops with 16 STOSW operations per iteration
    ' eliminating loop overhead for fastest possible A000h segment clear
    CALL Memory_ClearVideoMemory(color)
END SUB

' =============================================================================
' Fast block copy in VGA mode
' Parameters:
'   SrcX, SrcY - Source coordinates (BYVAL)
'   DestX, DestY - Destination coordinates (BYVAL)
'   width, Height - Block dimensions (BYVAL)
' Returns: Nothing
' Note: Optimized for Mode 13h with overlap handling
' =============================================================================
SUB Vga_CopyBlock(BYVAL srcX AS WORD, BYVAL srcY AS WORD, BYVAL destX AS WORD, BYVAL destY AS WORD, BYVAL width AS WORD, BYVAL height AS WORD)
    DIM CurrentY AS WORD, SrcOffset AS WORD, DestOffset AS WORD
    DIM CopyDirection AS INTEGER
    
    ' Determine copy direction to handle overlapping regions
    IF srcY < destY OR (srcY = destY AND srcX < destX) THEN
        ' Copy backwards (bottom to top, right to left)
        CopyDirection = -1
        CurrentY = height - 1
    ELSE
        ' Copy forwards (top to bottom, left to right)
        CopyDirection = 1
        CurrentY = 0
    END IF
    
    !PUSH ES
    !PUSH DS
    !MOV AX, &HA000
    !MOV ES, AX
    !MOV DS, AX
    
    IF CopyDirection = 1 THEN
        ' Forward copy
        DO WHILE CurrentY < height
            SrcOffset = (srcY + CurrentY) * 320 + srcX
            DestOffset = (destY + CurrentY) * 320 + destX
            
            !MOV SI, SrcOffset
            !MOV DI, DestOffset
            !MOV CX, width
            !CLD                    ; Clear direction flag (forward)
            
            ' 8086-compatible block move
            VGAForwardCopyLoop:
            !LODSB                  ; Load byte from DS:SI into AL, increment SI
            !STOSB                  ; Store AL to ES:DI, increment DI
            !LOOP VGAForwardCopyLoop
            
            CurrentY = CurrentY + 1
        LOOP
    ELSE
        ' Backward copy
        DO WHILE CurrentY >= 0
            SrcOffset = (srcY + CurrentY) * 320 + srcX + width - 1
            DestOffset = (destY + CurrentY) * 320 + destX + width - 1
            
            !MOV SI, SrcOffset
            !MOV DI, DestOffset
            !MOV CX, width
            !STD                    ; Set direction flag (backward)
            
            ' 8086-compatible backward block move
            VGABackwardCopyLoop:
            !LODSB                  ; Load byte from DS:SI into AL, decrement SI
            !STOSB                  ; Store AL to ES:DI, decrement DI
            !LOOP VGABackwardCopyLoop
            
            CurrentY = CurrentY - 1
        LOOP
    END IF
    
    !CLD                        ; Restore forward direction
    !POP DS
    !POP ES
END SUB

' =============================================================================
' Fast pattern fill in VGA mode
' Parameters:
'   X1, Y1 - Top-left corner (BYVAL)
'   X2, Y2 - Bottom-right corner (BYVAL)
'   Pattern - 8-byte pattern (STRING)
' Returns: Nothing
' Note: Fills area with repeating 8-byte pattern
' =============================================================================
SUB Vga_PatternFill(BYVAL x1 AS WORD, BYVAL y1 AS WORD, BYVAL x2 AS WORD, BYVAL y2 AS WORD, pattern AS STRING)
    DIM CurrentY AS WORD, CurrentX AS WORD, PatternIndex AS BYTE
    DIM LineOffset AS WORD
    
    ' Ensure coordinates are ordered
    IF x1 > x2 THEN SWAP x1, x2
    IF y1 > y2 THEN SWAP y1, y2
    
    ' Ensure pattern is at least 1 byte
    IF LEN(pattern) = 0 THEN pattern = CHR$(0)
    
    FOR CurrentY = y1 TO y2
        LineOffset = CurrentY * 320 + x1
        PatternIndex = 1
        
        !PUSH ES
        !MOV AX, &HA000
        !MOV ES, AX
        !MOV BX, LineOffset
        
        FOR CurrentX = x1 TO x2
            !MOV AL, ASC(MID$(pattern, PatternIndex, 1))
            !MOV ES:[BX], AL
            !INC BX
            
            PatternIndex = PatternIndex + 1
            IF PatternIndex > LEN(pattern) THEN PatternIndex = 1
        NEXT CurrentX
        
        !POP ES
    NEXT CurrentY
END SUB

' =============================================================================
' Get VGA mode information
' Parameters: None
' Returns: Nothing (updates global contexts)
' Note: Sets up contexts for Mode 13h
' =============================================================================
SUB Vga_InitMode13h
    ' Set Mode 13h context information
    SVGAScreenContext.XRes = 320
    SVGAScreenContext.YRes = 200
    SVGAScreenContext.ColorDepth = 8
    SVGAScreenContext.BytesPerLine = 320
    SVGAScreenContext.MemorySize = 64000
    SVGAScreenContext.WindowNumber = 0
    
    ' Update VESA context
    VESASystemContext.XRes = 320
    VESASystemContext.YRes = 200
    VESASystemContext.Window = 0
    VESASystemContext.Offset = 0
    VESASystemContext.XDecrease = 0
    VESASystemContext.YDecrease = 0
    VESASystemContext.CurrentMode = %SVGA_MODE13
    CALL Svga_InitDispatchTable  ' Update function pointers for Mode 13h
    
    ' Initialize scaling context
    ScaleSystemContext.XScale = 1
    ScaleSystemContext.YScale = 1
    ScaleSystemContext.KScale = 1
    ScaleSystemContext.XScaleMax = 320
    ScaleSystemContext.YScaleMax = 200
END SUB