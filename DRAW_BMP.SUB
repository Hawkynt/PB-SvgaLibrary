' =============================================================================
' DRAW_BMP.SUB - Extended Drawing Functions for Bitmap (Windows Bitmap) Image Format
' =============================================================================

' =============================================================================
' Display a BMP (Windows Bitmap) file
' Parameters:
'   FileName - Path to BMP file (BYREF)
'   X, Y - Display coordinates (BYVAL)
' Returns: Nothing
' Note: Supports 4-bit (16 color), 8-bit (256 color) BMP files
'       Automatically sets palette for 8-bit images
'       Uses optimized rendering based on current graphics mode
' =============================================================================
SUB DrawExt_ShowBMP(BYVAL FileName AS STRING, BYVAL X AS WORD, BYVAL Y AS WORD)
    DIM FileHandle AS INTEGER, HeaderData AS STRING
    DIM DataOffset AS LONG, ImageWidth AS LONG, ImageHeight AS LONG
    DIM ColorDepth AS WORD, NumColors AS WORD
    DIM ScanlineData AS STRING, PixelX AS WORD, PixelY AS WORD
    DIM PaletteIndex AS WORD, BytesPerLine AS WORD
    DIM PhysicalX AS WORD, PhysicalY AS WORD
    
    ' Convert virtual coordinates to physical
    CALL Virtual_ToPhysical(X, Y, PhysicalX, PhysicalY)
    
    ' Open BMP file
    FileHandle = FREEFILE
    OPEN FileName FOR BINARY AS #FileHandle
    
    ' Read BMP header information
    CALL BMP_ReadHeader(FileHandle, DataOffset, ImageWidth, ImageHeight, ColorDepth, NumColors)
    
    ' Update image context
    ImageSystemContext.X1 = 0
    ImageSystemContext.Y1 = 0
    ImageSystemContext.X2 = ImageWidth - 1
    ImageSystemContext.Y2 = ImageHeight - 1
    ImageSystemContext.ColorDepth = ColorDepth
    ImageSystemContext.BitsPerPixel = ColorDepth
    
    ' Load and set palette if 8-bit mode
    IF ColorDepth = 8 THEN
        CALL BMP_LoadPalette(FileHandle, NumColors)
    END IF
    
    ' Calculate bytes per scanline (must be DWORD-aligned)
    IF ColorDepth = 8 THEN
        BytesPerLine = ((ImageWidth + 3) \ 4) * 4
    ELSE
        BytesPerLine = ((ImageWidth + 7) \ 8) * 4  ' 4-bit packed
    END IF
    
    ' Read and display image data (BMPs are stored bottom-up)
    SEEK FileHandle, DataOffset
    
    FOR PixelY = ImageHeight - 1 TO 0 STEP -1
        GET$ FileHandle, BytesPerLine, ScanlineData
        
        ' Check if scanline is visible
        IF Virtual_IsVisible(X, Y + PixelY) THEN
            CALL BMP_DrawScanline(ScanlineData, PhysicalX, PhysicalY + PixelY, ImageWidth, ColorDepth)
        END IF
    NEXT PixelY
    
    CLOSE #FileHandle
END SUB

' =============================================================================
' Read BMP header information
' =============================================================================
SUB BMP_ReadHeader(BYVAL FileHandle AS INTEGER, DataOffset AS LONG, ImageWidth AS LONG, ImageHeight AS LONG, ColorDepth AS WORD, NumColors AS WORD)
    DIM HeaderData AS STRING
    
    ' Read data offset (offset 0x0A, 4 bytes)
    SEEK FileHandle, &HA
    GET$ FileHandle, 4, HeaderData
    DataOffset = ASC(MID$(HeaderData, 1, 1)) + 256& * ASC(MID$(HeaderData, 2, 1)) + 65536& * ASC(MID$(HeaderData, 3, 1)) + 16777216& * ASC(MID$(HeaderData, 4, 1))
    
    ' Read image width (offset 0x12, 4 bytes)
    SEEK FileHandle, &H12
    GET$ FileHandle, 4, HeaderData
    ImageWidth = ASC(MID$(HeaderData, 1, 1)) + 256& * ASC(MID$(HeaderData, 2, 1)) + 65536& * ASC(MID$(HeaderData, 3, 1)) + 16777216& * ASC(MID$(HeaderData, 4, 1))
    
    ' Read image height (offset 0x16, 4 bytes)
    GET$ FileHandle, 4, HeaderData
    ImageHeight = ASC(MID$(HeaderData, 1, 1)) + 256& * ASC(MID$(HeaderData, 2, 1)) + 65536& * ASC(MID$(HeaderData, 3, 1)) + 16777216& * ASC(MID$(HeaderData, 4, 1))
    
    ' Read color depth (offset 0x1C, 2 bytes)
    SEEK FileHandle, &H1C
    GET$ FileHandle, 2, HeaderData
    ColorDepth = ASC(MID$(HeaderData, 1, 1)) + 256 * ASC(MID$(HeaderData, 2, 1))
    NumColors = 2 ^ ColorDepth
END SUB

' =============================================================================
' Load BMP palette and set VGA palette
' =============================================================================
SUB BMP_LoadPalette(BYVAL FileHandle AS INTEGER, BYVAL NumColors AS WORD)
    DIM PaletteData AS STRING, ColorIndex AS WORD
    DIM RedValue AS BYTE, GreenValue AS BYTE, BlueValue AS BYTE
    
    ' Seek to palette location (after header)
    SEEK FileHandle, 55  ' Standard BMP palette location
    
    ' Read and set palette (BMP uses BGR format)
    FOR ColorIndex = 0 TO NumColors - 1
        GET$ FileHandle, 4, PaletteData  ' Read BGRA
        BlueValue = ASC(MID$(PaletteData, 1, 1)) \ 4    ' Scale to 6-bit
        GreenValue = ASC(MID$(PaletteData, 2, 1)) \ 4
        RedValue = ASC(MID$(PaletteData, 3, 1)) \ 4
        
        ' Set VGA palette register
        OUT &H3C8, ColorIndex
        OUT &H3C9, RedValue
        OUT &H3C9, GreenValue
        OUT &H3C9, BlueValue
    NEXT ColorIndex
END SUB

' =============================================================================
' Draw optimized BMP scanline
' =============================================================================
SUB BMP_DrawScanline(BYVAL ScanlineData AS STRING, BYVAL X AS WORD, BYVAL Y AS WORD, BYVAL Width AS WORD, BYVAL ColorDepth AS WORD)
    DIM PixelX AS WORD, DataIndex AS WORD, PixelColor AS BYTE
    
    IF ColorDepth = 8 THEN
        ' 8-bit mode - use fast horizontal line segments where possible
        DIM StartX AS WORD, CurrentColor AS BYTE, SegmentLength AS WORD
        
        StartX = X
        CurrentColor = ASC(MID$(ScanlineData, 1, 1))
        SegmentLength = 1
        DataIndex = 1
        
        FOR PixelX = 1 TO Width - 1
            DataIndex = DataIndex + 1
            PixelColor = ASC(MID$(ScanlineData, DataIndex, 1))
            
            IF PixelColor = CurrentColor THEN
                SegmentLength = SegmentLength + 1
            ELSE
                ' Draw accumulated segment
                IF SegmentLength > 1 THEN
                    CALL HLINE(StartX, StartX + SegmentLength - 1, Y, CurrentColor)
                ELSE
                    CALL PUTPIXEL(StartX, Y, CurrentColor)
                END IF
                
                ' Start new segment
                StartX = X + PixelX
                CurrentColor = PixelColor
                SegmentLength = 1
            END IF
        NEXT PixelX
        
        ' Draw final segment
        IF SegmentLength > 1 THEN
            CALL HLINE(StartX, StartX + SegmentLength - 1, Y, CurrentColor)
        ELSE
            CALL PUTPIXEL(StartX, Y, CurrentColor)
        END IF
        
    ELSE
        ' 4-bit mode - unpack and draw
        DataIndex = 1
        FOR PixelX = 0 TO Width - 1 STEP 2
            PixelColor = ASC(MID$(ScanlineData, DataIndex, 1))
            
            CALL PUTPIXEL(X + PixelX, Y, PixelColor \ 16)  ' High nibble
            IF PixelX + 1 < Width THEN
                CALL PUTPIXEL(X + PixelX + 1, Y, PixelColor AND 15)  ' Low nibble
            END IF
            
            DataIndex = DataIndex + 1
        NEXT PixelX
    END IF
END SUB

' =============================================================================
' Utility Functions
' =============================================================================

' =============================================================================
' Get BMP file dimensions without loading the image
' Parameters:
'   FileName - Path to BMP file (BYREF)
'   Width, Height - Output dimensions (BYREF)
' Returns: Nothing (dimensions returned via BYREF parameters)
' =============================================================================
SUB DrawExt_GetBMPSize(BYVAL FileName AS STRING, Width AS WORD, Height AS WORD)
    DIM FileHandle AS INTEGER, HeaderData AS STRING
    DIM ImageWidth AS LONG, ImageHeight AS LONG
    
    FileHandle = FREEFILE
    OPEN FileName FOR BINARY AS #FileHandle
    
    ' Read image dimensions from header
    SEEK FileHandle, &H12
    GET$ FileHandle, 4, HeaderData
    ImageWidth = ASC(MID$(HeaderData, 1, 1)) + 256& * ASC(MID$(HeaderData, 2, 1)) + 65536& * ASC(MID$(HeaderData, 3, 1)) + 16777216& * ASC(MID$(HeaderData, 4, 1))
    
    GET$ FileHandle, 4, HeaderData
    ImageHeight = ASC(MID$(HeaderData, 1, 1)) + 256& * ASC(MID$(HeaderData, 2, 1)) + 65536& * ASC(MID$(HeaderData, 3, 1)) + 16777216& * ASC(MID$(HeaderData, 4, 1))
    
    Width = ImageWidth
    Height = ImageHeight
    
    CLOSE #FileHandle
END SUB

' =============================================================================
' Get BMP palette without displaying the image
' Parameters:
'   FileName - Path to BMP file (BYREF)
'   Palette - Output palette array (BYREF)
'   ColorDepth - Bits per pixel (BYVAL)
' Returns: Nothing (palette returned via BYREF array)
' =============================================================================
SUB DrawExt_GetBMPPalette(BYVAL FileName AS STRING, Palette() AS BYTE, BYVAL ColorDepth AS BYTE)
    DIM FileHandle AS INTEGER, PaletteData AS STRING
    DIM NumColors AS WORD, ColorIndex AS WORD, ArrayIndex AS WORD
    
    NumColors = 2 ^ ColorDepth
    FileHandle = FREEFILE
    OPEN FileName FOR BINARY AS #FileHandle
    
    ' Seek to palette location
    SEEK FileHandle, 55
    
    ArrayIndex = 0
    FOR ColorIndex = 0 TO NumColors - 1
        GET$ FileHandle, 4, PaletteData  ' Read BGRA
        
        Palette(ArrayIndex) = ASC(MID$(PaletteData, 3, 1))      ' Red
        Palette(ArrayIndex + 1) = ASC(MID$(PaletteData, 2, 1))  ' Green
        Palette(ArrayIndex + 2) = ASC(MID$(PaletteData, 1, 1))  ' Blue
        ArrayIndex = ArrayIndex + 3
    NEXT ColorIndex
    
    CLOSE #FileHandle
END SUB