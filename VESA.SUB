' =============================================================================
' VESA.SUB - VESA Graphics Mode Management
' =============================================================================
' Contains VESA BIOS Extension functions for high-resolution graphics modes
' =============================================================================

' =============================================================================
' Set graphics resolution using VESA or VGA modes
' Parameters:
'   XRes - Desired X resolution (BYVAL)
'   YRes - Desired Y resolution (BYVAL)
'   Colors - Desired number of colors (BYVAL)
' Returns: Nothing
' Note: Automatically selects best available mode, falls back to simulation if exact mode unavailable
'       Updates global VESASystemContext and SVGAScreenContext
' =============================================================================
SUB SETRES (BYVAL XRes AS WORD, BYVAL YRes AS WORD, BYVAL Colors AS WORD)
    DIM VESAInfo AS STRING, ModeInfo AS STRING
    DIM FarOffset AS WORD, FarSegment AS WORD
    DIM ModeIndex AS WORD, ModeNumber AS WORD, TestMode AS WORD
    DIM ModeXRes AS WORD, ModeYRes AS WORD, ModeColors AS WORD
    DIM BestMode AS WORD, BestXDiff AS INTEGER, BestYDiff AS INTEGER
    
    ' Handle standard VGA mode 13h (320x200x256)
    IF (XRes = 320) AND (YRes = 200) AND (Colors = 256) THEN
        CALL SETVGA(13)
        VESASystemContext.CurrentMode = %SVGA_MODE13
        CALL InitDispatchTable  ' Update function pointers for mode 13h
        EXIT SUB
    END IF
    
    ' Prepare buffers for VESA calls
    VESAInfo = STRING$(256, CHR$(219))
    ModeInfo = STRING$(256, CHR$(219))
    
    ' Get VESA information (Function 4F00h)
    REG 1, &H4F00
    REG 6, STRPTR(VESAInfo)
    REG 9, STRSEG(VESAInfo)
    CALL INTERRUPT &H10
    
    ' Extract pointer to video mode list
    FarOffset = ASC(MID$(VESAInfo, 15, 1)) + 256 * ASC(MID$(VESAInfo, 16, 1))
    FarSegment = ASC(MID$(VESAInfo, 17, 1)) + 256 * ASC(MID$(VESAInfo, 18, 1))
    DEF SEG = FarSegment
    
    ' Search for exact mode match
    ModeIndex = 0
    DO
        ModeNumber = PEEK(FarOffset + ModeIndex) + 256 * PEEK(FarOffset + ModeIndex + 1)
        IF ModeNumber = 65535 THEN EXIT DO  ' End of mode list
        
        ' Get mode information (Function 4F01h)
        REG 1, &H4F01
        REG 3, ModeNumber
        REG 9, STRSEG(ModeInfo)
        REG 6, STRPTR(ModeInfo)
        CALL INTERRUPT &H10
        
        ' Extract mode parameters
        ModeXRes = ASC(MID$(ModeInfo, &H13, 1)) + 256 * ASC(MID$(ModeInfo, &H14, 1))
        ModeYRes = ASC(MID$(ModeInfo, &H15, 1)) + 256 * ASC(MID$(ModeInfo, &H16, 1))
        ModeColors = 2 ^ ASC(MID$(ModeInfo, &H1A, 1))
        
        ' Check for exact match
        IF XRes = ModeXRes AND YRes = ModeYRes AND Colors = ModeColors THEN
            CALL SETVGA(ModeNumber)
            VESASystemContext.CurrentMode = %SVGA_VESA
            CALL InitDispatchTable  ' Update function pointers for VESA mode
            EXIT SUB
        END IF
        
        ModeIndex = ModeIndex + 2
    LOOP
    
    ' If no exact match, find closest higher resolution for simulation
    ModeIndex = 0
    BestXDiff = 32767
    BestYDiff = 32767
    BestMode = 0
    
    DO
        ModeNumber = PEEK(FarOffset + ModeIndex) + 256 * PEEK(FarOffset + ModeIndex + 1)
        IF ModeNumber = 65535 THEN EXIT DO  ' End of mode list
        
        ' Get mode information
        REG 1, &H4F01
        REG 3, ModeNumber
        REG 9, STRSEG(ModeInfo)
        REG 6, STRPTR(ModeInfo)
        CALL INTERRUPT &H10
        
        ' Extract mode parameters
        ModeXRes = ASC(MID$(ModeInfo, &H13, 1)) + 256 * ASC(MID$(ModeInfo, &H14, 1))
        ModeYRes = ASC(MID$(ModeInfo, &H15, 1)) + 256 * ASC(MID$(ModeInfo, &H16, 1))
        ModeColors = 2 ^ ASC(MID$(ModeInfo, &H1A, 1))
        
        ' Check if this mode is suitable for simulation (higher or equal resolution)
        IF ModeXRes >= XRes AND ModeYRes >= YRes AND ModeColors >= Colors THEN
            DIM XDiff AS INTEGER, YDiff AS INTEGER
            XDiff = ModeXRes - XRes
            YDiff = ModeYRes - YRes
            
            ' Check if this is a better match than previous best
            IF XDiff < BestXDiff OR (XDiff = BestXDiff AND YDiff < BestYDiff) THEN
                BestXDiff = XDiff
                BestYDiff = YDiff
                BestMode = ModeNumber
            END IF
        END IF
        
        ModeIndex = ModeIndex + 2
    LOOP
    
    ' Set the best available mode
    IF BestMode > 0 THEN
        CALL SETVGA(BestMode)
        VESASystemContext.CurrentMode = %SVGA_VESA
        CALL InitDispatchTable  ' Update function pointers for VESA mode
        ' Set up coordinate scaling for simulation
        VESASystemContext.XDecrease = BestXDiff / 2
        VESASystemContext.YDecrease = BestYDiff / 2
    ELSE
        ' Fallback to mode 13h if no suitable mode found
        CALL SETVGA(13)
        VESASystemContext.CurrentMode = %SVGA_MODE13
        CALL InitDispatchTable  ' Update function pointers for mode 13h
        EXIT SUB
    END IF
    
    ' Check for VESA support and get VESA information
    DIM VESAInfo AS STRING
    VESAInfo = STRING$(256, CHR$(219))
    REG 1, &H4F00
    REG 6, STRPTR(VESAInfo)
    REG 9, STRSEG(VESAInfo)
    CALL INTERRUPT &H10
    
    IF (AX AND &HFFFF) <> &H4F THEN
        ' VESA not supported, try Mode-X fallback
        CALL ModeX_SetFallback(XRes, YRes, Colors)
        EXIT SUB
    END IF
    
    DEF SEG  ' Restore default segment
END SUB

' =============================================================================
' Set VESA graphics mode
' Parameters:
'   ModeNumber - VESA mode number to set (BYVAL)
' Returns: Nothing
' Note: Sets hardware graphics mode and updates global context variables
' =============================================================================
SUB SETVGA (BYVAL ModeNumber AS INTEGER)
    DIM ModeInfo AS STRING
    
    ' Set VESA graphics mode (Function 4F02h)
    REG 1, &H4F02
    REG 2, ModeNumber
    CALL INTERRUPT &H10
    
    ' Get mode information for context setup
    ModeInfo = STRING$(256, CHR$(219))
    REG 1, &H4F01
    REG 3, ModeNumber
    REG 9, STRSEG(ModeInfo)
    REG 6, STRPTR(ModeInfo)
    CALL INTERRUPT &H10
    
    ' Update global context with mode information
    SVGAScreenContext.XRes = ASC(MID$(ModeInfo, &H13, 1)) + 256 * ASC(MID$(ModeInfo, &H14, 1))
    SVGAScreenContext.YRes = ASC(MID$(ModeInfo, &H15, 1)) + 256 * ASC(MID$(ModeInfo, &H16, 1))
    SVGAScreenContext.ColorDepth = ASC(MID$(ModeInfo, &H1A, 1))
    SVGAScreenContext.BytesPerLine = ASC(MID$(ModeInfo, &H11, 1)) + 256 * ASC(MID$(ModeInfo, &H12, 1))
    SVGAScreenContext.WindowGranularity = ASC(MID$(ModeInfo, &H5, 1)) + 256 * ASC(MID$(ModeInfo, &H6, 1))
    
    ' Update VESA context
    VESASystemContext.XRes = SVGAScreenContext.XRes
    VESASystemContext.YRes = SVGAScreenContext.YRes
    VESASystemContext.Window = 0
    
    ' Initialize scaling context for default 1:1 scaling
    ScaleSystemContext.XScale = 1
    ScaleSystemContext.YScale = 1
    ScaleSystemContext.KScale = 1
    ScaleSystemContext.XScaleMax = SVGAScreenContext.XRes
    ScaleSystemContext.YScaleMax = SVGAScreenContext.YRes
END SUB

' =============================================================================
' Return to text mode and cleanup graphics
' Parameters: None
' Returns: Nothing
' Note: Restores original video mode and clears graphics context
' =============================================================================
SUB CLOSEVGA
    ' Set text mode (Mode 03h - 80x25 color text)
    REG 1, &H0003
    CALL INTERRUPT &H10
    
    ' Clear graphics contexts
    SVGAScreenContext.XRes = 0
    SVGAScreenContext.YRes = 0
    SVGAScreenContext.ColorDepth = 0
    SVGAScreenContext.WindowNumber = 0
    
    VESASystemContext.XRes = 0
    VESASystemContext.YRes = 0
    VESASystemContext.Window = 0
    VESASystemContext.Offset = 0
    VESASystemContext.CurrentMode = %SVGA_MODE13  ' Reset to default
    
    ' Reset scaling
    ScaleSystemContext.XScale = 1
    ScaleSystemContext.YScale = 1
    ScaleSystemContext.KScale = 1
END SUB

' =============================================================================
' Get the best VESA mode number for given parameters
' Parameters:
'   XRes - Desired X resolution (BYVAL)
'   YRes - Desired Y resolution (BYVAL)
'   Colors - Desired number of colors (BYVAL)
' Returns: VESA mode number, or 0 if no suitable mode found
' =============================================================================
FUNCTION GETVESAMODE (BYVAL XRes AS WORD, BYVAL YRes AS WORD, BYVAL Colors AS WORD) AS WORD
    DIM VESAInfo AS STRING, ModeInfo AS STRING
    DIM FarOffset AS WORD, FarSegment AS WORD
    DIM ModeIndex AS WORD, ModeNumber AS WORD
    DIM ModeXRes AS WORD, ModeYRes AS WORD, ModeColors AS WORD
    
    ' Prepare buffer for VESA call
    VESAInfo = STRING$(256, CHR$(219))
    ModeInfo = STRING$(256, CHR$(219))
    
    ' Get VESA information
    REG 1, &H4F00
    REG 6, STRPTR(VESAInfo)
    REG 9, STRSEG(VESAInfo)
    CALL INTERRUPT &H10
    
    ' Extract pointer to video mode list
    FarOffset = ASC(MID$(VESAInfo, 15, 1)) + 256 * ASC(MID$(VESAInfo, 16, 1))
    FarSegment = ASC(MID$(VESAInfo, 17, 1)) + 256 * ASC(MID$(VESAInfo, 18, 1))
    DEF SEG = FarSegment
    
    ' Search for exact mode match
    ModeIndex = 0
    DO
        ModeNumber = PEEK(FarOffset + ModeIndex) + 256 * PEEK(FarOffset + ModeIndex + 1)
        IF ModeNumber = 65535 THEN EXIT DO  ' End of mode list
        
        ' Get mode information
        REG 1, &H4F01
        REG 3, ModeNumber
        REG 9, STRSEG(ModeInfo)
        REG 6, STRPTR(ModeInfo)
        CALL INTERRUPT &H10
        
        ' Extract mode parameters
        ModeXRes = ASC(MID$(ModeInfo, &H13, 1)) + 256 * ASC(MID$(ModeInfo, &H14, 1))
        ModeYRes = ASC(MID$(ModeInfo, &H15, 1)) + 256 * ASC(MID$(ModeInfo, &H16, 1))
        ModeColors = 2 ^ ASC(MID$(ModeInfo, &H1A, 1))
        
        ' Check for exact match
        IF XRes = ModeXRes AND YRes = ModeYRes AND Colors = ModeColors THEN
            DEF SEG  ' Restore default segment
            GETVESAMODE = ModeNumber
            EXIT FUNCTION
        END IF
        
        ModeIndex = ModeIndex + 2
    LOOP
    
    DEF SEG  ' Restore default segment
    GETVESAMODE = 0  ' No suitable mode found
END FUNCTION

' =============================================================================
' Display VESA card information
' Parameters: None
' Returns: Nothing (displays information to console)
' Note: Shows VESA BIOS version, video memory, and available modes
' =============================================================================
SUB VGAINFO
    DIM VESAInfo AS STRING
    DIM VESAVersion AS WORD, VideoMemory AS WORD
    
    ' Get VESA information
    VESAInfo = STRING$(256, CHR$(219))
    REG 1, &H4F00
    REG 6, STRPTR(VESAInfo)
    REG 9, STRSEG(VESAInfo)
    CALL INTERRUPT &H10
    
    ' Extract VESA version
    VESAVersion = ASC(MID$(VESAInfo, 5, 1)) + 256 * ASC(MID$(VESAInfo, 6, 1))
    
    ' Extract video memory size (in 64KB blocks)
    VideoMemory = ASC(MID$(VESAInfo, 19, 1)) + 256 * ASC(MID$(VESAInfo, 20, 1))
    
    ' Display information
    PRINT "VESA BIOS Version: "; HEX$(VESAVersion)
    PRINT "Video Memory: "; VideoMemory * 64; "KB"
    PRINT "Graphics modes supported by current hardware."
END SUB

' =============================================================================
' VESA Drawing Primitives - Optimized for VESA linear and banked modes
' =============================================================================

' =============================================================================
' Set pixel in VESA mode (optimized for banking)
' Parameters:
'   X, Y - Pixel coordinates (BYVAL)
'   Color - Pixel color value (BYVAL)
' Returns: Nothing
' Note: Handles VESA window switching automatically
' =============================================================================
SUB VESA_PutPixel(BYVAL X AS WORD, BYVAL Y AS WORD, BYVAL Color AS BYTE)
    DIM ByteOffset AS LONG, WindowNumber AS WORD, PixelOffset AS WORD
    
    ' Calculate pixel address
    IF SVGAScreenContext.ColorDepth = 8 THEN
        ' 8-bit color mode
        ByteOffset = Y * SVGAScreenContext.BytesPerLine + X
        WindowNumber = ByteOffset \ 65536  ' 64K window size
        PixelOffset = ByteOffset MOD 65536
        
        ' Switch VESA window if needed
        IF WindowNumber <> SVGAScreenContext.WindowNumber THEN
            CALL SETVESAWINDOW(WindowNumber)
            SVGAScreenContext.WindowNumber = WindowNumber
        END IF
        
        ' Set pixel using direct memory access
        DEF SEG = &HA000
        POKE PixelOffset, Color
        DEF SEG
    ELSE
        ' Fallback for other color depths
        DEF SEG = &HA000
        POKE Y * SVGAScreenContext.BytesPerLine + X, Color
        DEF SEG
    END IF
END SUB

' =============================================================================
' Get pixel from VESA mode
' Parameters:
'   X, Y - Pixel coordinates (BYVAL)
' Returns: Pixel color value
' =============================================================================
FUNCTION VESA_GetPixel(BYVAL X AS WORD, BYVAL Y AS WORD) AS BYTE
    DIM ByteOffset AS LONG, WindowNumber AS WORD, PixelOffset AS WORD
    
    IF SVGAScreenContext.ColorDepth = 8 THEN
        ByteOffset = Y * SVGAScreenContext.BytesPerLine + X
        WindowNumber = ByteOffset \ 65536
        PixelOffset = ByteOffset MOD 65536
        
        ' Switch VESA window if needed
        IF WindowNumber <> SVGAScreenContext.WindowNumber THEN
            CALL SETVESAWINDOW(WindowNumber)
            SVGAScreenContext.WindowNumber = WindowNumber
        END IF
        
        ' Get pixel value
        DEF SEG = &HA000
        VESA_GetPixel = PEEK(PixelOffset)
        DEF SEG
    ELSE
        ' Fallback
        DEF SEG = &HA000
        VESA_GetPixel = PEEK(Y * SVGAScreenContext.BytesPerLine + X)
        DEF SEG
    END IF
END FUNCTION

' =============================================================================
' Draw horizontal line in VESA mode (optimized for banking)
' Parameters:
'   X1, X2 - Start and end X coordinates (BYVAL)
'   Y - Y coordinate (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' Note: Optimized to minimize window switches
' =============================================================================
SUB VESA_HLine(BYVAL X1 AS WORD, BYVAL X2 AS WORD, BYVAL Y AS WORD, BYVAL Color AS BYTE)
    DIM StartOffset AS LONG, EndOffset AS LONG
    DIM CurrentWindow AS WORD, BytesInWindow AS WORD
    DIM LineLength AS WORD, CurrentX AS WORD
    DIM ColorWord AS WORD, ColorDWord AS LONG
    DIM WindowOffset AS WORD
    
    ' Ensure X1 <= X2
    IF X1 > X2 THEN SWAP X1, X2
    
    StartOffset = Y * SVGAScreenContext.BytesPerLine + X1
    EndOffset = Y * SVGAScreenContext.BytesPerLine + X2
    LineLength = X2 - X1 + 1
    CurrentX = X1
    
    ' Prepare color patterns for faster filling
    ColorWord = (Color * 256) + Color      ' AABBH pattern
    ColorDWord = (ColorWord * 65536&) + ColorWord  ' AABBAABBH pattern
    
    ' Draw line across windows if necessary
    DO WHILE CurrentX <= X2
        CurrentWindow = StartOffset \ 65536
        
        ' Switch to correct window
        IF CurrentWindow <> SVGAScreenContext.WindowNumber THEN
            CALL SETVESAWINDOW(CurrentWindow)
            SVGAScreenContext.WindowNumber = CurrentWindow
        END IF
        
        ' Calculate how many pixels we can draw in this window
        BytesInWindow = 65536 - (StartOffset MOD 65536)
        IF BytesInWindow > (X2 - CurrentX + 1) THEN
            BytesInWindow = X2 - CurrentX + 1
        END IF
        
        WindowOffset = StartOffset AND &HFFFF  ' Offset within current window
        
        ' Draw pixels in current window using optimized WORD fills
        !PUSH ES
        !MOV AX, &HA000
        !MOV ES, AX
        !MOV BX, WindowOffset
        !MOV CX, BytesInWindow
        
        ' Handle odd starting pixel if not word-aligned
        !TEST BX, 1             ; Check if starting address is odd
        !JZ VESAHLineWordAlign  ; Jump if even (word-aligned)
        !CMP CX, 0              ; Check if we have pixels to draw
        !JZ VESAHLineDone       ; Done if no pixels
        !MOV AL, Color
        !MOV ES:[BX], AL        ; Fill first pixel
        !INC BX
        !DEC CX
        !JZ VESAHLineDone       ; Done if only one pixel
        
        VESAHLineWordAlign:
        ' Fill using WORD writes (2 pixels at a time)
        !MOV DX, CX
        !SHR CX, 1              ; Divide by 2 for word count
        !JZ VESAHLineRemainder  ; Jump if less than 2 pixels left
        !MOV AX, ColorWord
        
        VESAHLineWordFill:
        !MOV ES:[BX], AX        ; Write 2 pixels at once
        !ADD BX, 2
        !LOOP VESAHLineWordFill
        
        VESAHLineRemainder:
        ' Handle remaining odd pixel
        !TEST DX, 1             ; Check if original length was odd
        !JZ VESAHLineDone       ; Jump if no remainder
        !MOV AL, Color
        !MOV ES:[BX], AL        ; Fill last pixel
        
        VESAHLineDone:
        !POP ES
        
        ' Move to next section
        CurrentX = CurrentX + BytesInWindow
        StartOffset = StartOffset + BytesInWindow
    LOOP
END SUB

' =============================================================================
' Draw vertical line in VESA mode (optimized for minimal window switches)
' Parameters:
'   X - X coordinate (BYVAL)
'   Y1, Y2 - Start and end Y coordinates (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' Note: Pre-calculates window boundaries to minimize window switching overhead
' =============================================================================
SUB VESA_VLine(BYVAL X AS WORD, BYVAL Y1 AS WORD, BYVAL Y2 AS WORD, BYVAL Color AS BYTE)
    DIM StartOffset AS LONG, EndOffset AS LONG, CurrentOffset AS LONG
    DIM CurrentWindow AS WORD, WindowStartY AS WORD, WindowEndY AS WORD
    DIM BytesPerLine AS WORD, PixelsPerWindow AS WORD
    DIM WindowOffset AS WORD, PixelCount AS WORD
    DIM CurrentY AS WORD
    
    ' Ensure Y1 <= Y2
    IF Y1 > Y2 THEN SWAP Y1, Y2
    
    BytesPerLine = SVGAScreenContext.BytesPerLine
    PixelsPerWindow = 65536 \ BytesPerLine  ' How many scanlines fit in a 64K window
    
    ' Calculate start and end offsets
    StartOffset = Y1 * BytesPerLine + X
    EndOffset = Y2 * BytesPerLine + X
    CurrentOffset = StartOffset
    CurrentY = Y1
    
    ' Process line by windows to minimize window switches
    DO WHILE CurrentY <= Y2
        CurrentWindow = CurrentOffset \ 65536
        
        ' Calculate Y range that fits in current window
        WindowStartY = CurrentY
        WindowEndY = ((CurrentWindow + 1) * 65536 - X - 1) \ BytesPerLine
        IF WindowEndY > Y2 THEN WindowEndY = Y2
        
        ' Switch to current window once
        IF CurrentWindow <> SVGAScreenContext.WindowNumber THEN
            CALL SETVESAWINDOW(CurrentWindow)
            SVGAScreenContext.WindowNumber = CurrentWindow
        END IF
        
        ' Draw all pixels in this window using fast assembly
        WindowOffset = CurrentOffset AND &HFFFF  ' Offset within window
        PixelCount = WindowEndY - WindowStartY + 1
        
        !PUSH ES
        !MOV AX, &HA000
        !MOV ES, AX
        !MOV BX, WindowOffset
        !MOV AL, Color
        !MOV DX, BytesPerLine    ; Step between scanlines
        !MOV CX, PixelCount
        
        ' Optimized vertical line loop within window
        VESAVLineWindowLoop:
        !MOV ES:[BX], AL
        !ADD BX, DX             ; Move to next scanline
        !LOOP VESAVLineWindowLoop
        
        !POP ES
        
        ' Move to next window
        CurrentY = WindowEndY + 1
        CurrentOffset = CurrentY * BytesPerLine + X
    LOOP
END SUB

' =============================================================================
' Draw line between two points in VESA mode
' Parameters:
'   X1, Y1 - Starting point coordinates (BYVAL)
'   X2, Y2 - Ending point coordinates (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' Note: Uses optimized routines for horizontal/vertical lines
' =============================================================================
SUB VESA_LineDraw(BYVAL X1 AS WORD, BYVAL Y1 AS WORD, BYVAL X2 AS WORD, BYVAL Y2 AS WORD, BYVAL Color AS BYTE)
    ' Check for horizontal line
    IF Y1 = Y2 THEN
        CALL VESA_HLine(X1, X2, Y1, Color)
        EXIT SUB
    END IF
    
    ' Check for vertical line
    IF X1 = X2 THEN
        CALL VESA_VLine(X1, Y1, Y2, Color)
        EXIT SUB
    END IF
    
    ' Diagonal line - use Bresenham's algorithm
    DIM DeltaX AS INTEGER, DeltaY AS INTEGER, StepX AS INTEGER, StepY AS INTEGER
    DIM ErrorTerm AS INTEGER, CurrentX AS WORD, CurrentY AS WORD
    
    ' Calculate deltas and step directions
    DeltaX = ABS(X2 - X1)
    DeltaY = ABS(Y2 - Y1)
    
    IF X1 < X2 THEN StepX = 1 ELSE StepX = -1
    IF Y1 < Y2 THEN StepY = 1 ELSE StepY = -1
    
    ' Initialize error term
    ErrorTerm = DeltaX - DeltaY
    
    ' Set starting position
    CurrentX = X1
    CurrentY = Y1
    
    ' Draw line using Bresenham's algorithm
    DO
        CALL VESA_PutPixel(CurrentX, CurrentY, Color)
        
        ' Check if we've reached the end point
        IF CurrentX = X2 AND CurrentY = Y2 THEN EXIT DO
        
        ' Calculate next point
        DIM Error2 AS INTEGER
        Error2 = ErrorTerm * 2
        
        IF Error2 > -DeltaY THEN
            ErrorTerm = ErrorTerm - DeltaY
            CurrentX = CurrentX + StepX
        END IF
        
        IF Error2 < DeltaX THEN
            ErrorTerm = ErrorTerm + DeltaX
            CurrentY = CurrentY + StepY
        END IF
    LOOP
END SUB

' =============================================================================
' Draw filled rectangle in VESA mode
' Parameters:
'   X1, Y1 - Top-left corner (BYVAL)
'   X2, Y2 - Bottom-right corner (BYVAL)
'   Color - Fill color (BYVAL)
' Returns: Nothing
' Note: Uses optimized horizontal line fills
' =============================================================================
SUB VESA_FillRect(BYVAL X1 AS WORD, BYVAL Y1 AS WORD, BYVAL X2 AS WORD, BYVAL Y2 AS WORD, BYVAL Color AS BYTE)
    DIM ScanLine AS WORD
    
    ' Ensure coordinates are ordered
    IF X1 > X2 THEN SWAP X1, X2
    IF Y1 > Y2 THEN SWAP Y1, Y2
    
    ' Fill rectangle using horizontal lines
    FOR ScanLine = Y1 TO Y2
        CALL VESA_HLine(X1, X2, ScanLine, Color)
    NEXT ScanLine
END SUB

' =============================================================================
' Draw rectangle outline in VESA mode
' Parameters:
'   X1, Y1 - Top-left corner (BYVAL)
'   X2, Y2 - Bottom-right corner (BYVAL)
'   Color - Border color (BYVAL)
' Returns: Nothing
' =============================================================================
SUB VESA_DrawRect(BYVAL X1 AS WORD, BYVAL Y1 AS WORD, BYVAL X2 AS WORD, BYVAL Y2 AS WORD, BYVAL Color AS BYTE)
    ' Ensure coordinates are ordered
    IF X1 > X2 THEN SWAP X1, X2
    IF Y1 > Y2 THEN SWAP Y1, Y2
    
    ' Draw four sides
    CALL VESA_HLine(X1, X2, Y1, Color)  ' Top
    CALL VESA_HLine(X1, X2, Y2, Color)  ' Bottom
    CALL VESA_VLine(X1, Y1, Y2, Color)  ' Left
    CALL VESA_VLine(X2, Y1, Y2, Color)  ' Right
END SUB

' =============================================================================
' Clear VESA screen to specified color
' Parameters:
'   Color - Fill color (BYVAL)
' Returns: Nothing
' Note: Optimized for VESA banking
' =============================================================================
SUB VESA_ClearScreen(BYVAL Color AS BYTE)
    DIM TotalBytes AS LONG, WindowNumber AS WORD
    DIM CurrentWindow AS WORD
    DIM ColorWord AS WORD, ColorDWord AS LONG
    
    TotalBytes = SVGAScreenContext.BytesPerLine * SVGAScreenContext.YRes
    CurrentWindow = 0
    
    ' Prepare color patterns for faster filling
    ColorWord = (Color * 256) + Color      ' AABBH pattern
    ColorDWord = (ColorWord * 65536&) + ColorWord  ' AABBAABBH pattern
    
    ' Fill screen using VESA banking with optimized fills
    DO WHILE TotalBytes > 0
        CALL SETVESAWINDOW(CurrentWindow)
        SVGAScreenContext.WindowNumber = CurrentWindow
        
        DIM BytesToFill AS WORD
        IF TotalBytes > 65536 THEN
            BytesToFill = 65536
        ELSE
            BytesToFill = TotalBytes
        END IF
        
        ' Fast fill using WORD writes where possible
        !PUSH ES
        !MOV AX, &HA000
        !MOV ES, AX
        !XOR BX, BX             ; Start at offset 0 of the window
        !MOV CX, BytesToFill
        
        ' Handle odd starting byte if not word-aligned
        !TEST BX, 1             ; Check if starting address is odd (always 0 here)
        !JZ VESAClearWordAlign  ; Jump if even (word-aligned)
        !MOV AL, Color
        !MOV ES:[BX], AL        ; Fill first byte
        !INC BX
        !DEC CX
        !JZ VESAClearDone       ; Done if only one byte
        
        VESAClearWordAlign:
        ' Fill using WORD writes (2 bytes at a time)
        !MOV DX, CX
        !SHR CX, 1              ; Divide by 2 for word count
        !JZ VESAClearRemainder  ; Jump if less than 2 bytes left
        !MOV AX, ColorWord
        
        VESAClearWordFill:
        !MOV ES:[BX], AX        ; Write 2 bytes at once
        !ADD BX, 2
        !LOOP VESAClearWordFill
        
        VESAClearRemainder:
        ' Handle remaining odd byte
        !TEST DX, 1             ; Check if original length was odd
        !JZ VESAClearDone       ; Jump if no remainder
        !MOV AL, Color
        !MOV ES:[BX], AL        ; Fill last byte
        
        VESAClearDone:
        !POP ES
        
        TotalBytes = TotalBytes - BytesToFill
        CurrentWindow = CurrentWindow + 1
    LOOP
END SUB

' =============================================================================
' Fast block copy in VESA mode (optimized for window batching)
' Parameters:
'   SrcX, SrcY - Source coordinates (BYVAL)
'   DestX, DestY - Destination coordinates (BYVAL)
'   Width, Height - Block dimensions (BYVAL)
' Returns: Nothing
' Note: Pre-calculates window operations to minimize banking overhead
' =============================================================================
SUB VESA_CopyBlock(BYVAL SrcX AS WORD, BYVAL SrcY AS WORD, BYVAL DestX AS WORD, BYVAL DestY AS WORD, BYVAL Width AS WORD, BYVAL Height AS WORD)
    DIM CurrentY AS WORD, CurrentX AS WORD
    DIM SrcOffset AS LONG, DestOffset AS LONG
    DIM SrcWindow AS WORD, DestWindow AS WORD, LastSrcWindow AS WORD, LastDestWindow AS WORD
    DIM BytesPerLine AS WORD, SrcWindowOffset AS WORD, DestWindowOffset AS WORD
    DIM ScanlineData AS STRING
    
    BytesPerLine = SVGAScreenContext.BytesPerLine
    LastSrcWindow = -1  ' Force initial window switch
    LastDestWindow = -1
    
    ' Process block scanline by scanline with window optimization
    FOR CurrentY = 0 TO Height - 1
        ' Calculate source and destination offsets for this scanline
        SrcOffset = (SrcY + CurrentY) * BytesPerLine + SrcX
        DestOffset = (DestY + CurrentY) * BytesPerLine + DestX
        
        SrcWindow = SrcOffset \ 65536
        DestWindow = DestOffset \ 65536
        
        ' Check if we need to copy within same window (optimization opportunity)
        IF SrcWindow = DestWindow AND Width <= (65536 - (SrcOffset MOD 65536)) THEN
            ' Source and destination are in same window - ultra-fast copy
            IF SrcWindow <> LastSrcWindow THEN
                CALL SETVESAWINDOW(SrcWindow)
                SVGAScreenContext.WindowNumber = SrcWindow
                LastSrcWindow = SrcWindow
            END IF
            
            SrcWindowOffset = SrcOffset AND &HFFFF
            DestWindowOffset = DestOffset AND &HFFFF
            
            ' Fast intra-window block copy using assembly
            !PUSH ES
            !PUSH DS
            !MOV AX, &HA000
            !MOV ES, AX
            !MOV DS, AX
            !MOV SI, SrcWindowOffset
            !MOV DI, DestWindowOffset
            !MOV CX, Width
            !CLD                    ; Forward copy
            
            ' Copy entire scanline at once
            VESAIntraWindowCopy:
            !LODSB                  ; Load from DS:SI
            !STOSB                  ; Store to ES:DI
            !LOOP VESAIntraWindowCopy
            
            !POP DS
            !POP ES
        ELSE
            ' Cross-window copy or complex case - use optimized pixel-by-pixel
            CALL VESA_CopyScanline(SrcX, SrcY + CurrentY, DestX, DestY + CurrentY, Width)
        END IF
    NEXT CurrentY
END SUB

' =============================================================================
' Copy single scanline with window optimization
' =============================================================================
SUB VESA_CopyScanline(BYVAL SrcX AS WORD, BYVAL SrcY AS WORD, BYVAL DestX AS WORD, BYVAL DestY AS WORD, BYVAL Width AS WORD)
    DIM CurrentX AS WORD, PixelColor AS BYTE
    DIM SrcOffset AS LONG, DestOffset AS LONG
    DIM SrcWindow AS WORD, DestWindow AS WORD
    DIM LastSrcWindow AS WORD, LastDestWindow AS WORD
    
    LastSrcWindow = -1
    LastDestWindow = -1
    
    ' Optimized scanline copy with minimal window switches
    FOR CurrentX = 0 TO Width - 1
        SrcOffset = SrcY * SVGAScreenContext.BytesPerLine + SrcX + CurrentX
        SrcWindow = SrcOffset \ 65536
        
        ' Switch source window only when needed
        IF SrcWindow <> LastSrcWindow THEN
            CALL SETVESAWINDOW(SrcWindow)
            SVGAScreenContext.WindowNumber = SrcWindow
            LastSrcWindow = SrcWindow
        END IF
        
        ' Read pixel from current window
        !PUSH ES
        !MOV AX, &HA000
        !MOV ES, AX
        !MOV BX, SrcOffset
        !AND BX, &HFFFF         ; Window offset
        !MOV AL, ES:[BX]
        !MOV PixelColor, AL
        !POP ES
        
        ' Write pixel to destination
        DestOffset = DestY * SVGAScreenContext.BytesPerLine + DestX + CurrentX
        DestWindow = DestOffset \ 65536
        
        ' Switch destination window only when needed
        IF DestWindow <> LastDestWindow AND DestWindow <> LastSrcWindow THEN
            CALL SETVESAWINDOW(DestWindow)
            SVGAScreenContext.WindowNumber = DestWindow
            LastDestWindow = DestWindow
        END IF
        
        ' Write pixel to current window
        !PUSH ES
        !MOV AX, &HA000
        !MOV ES, AX
        !MOV BX, DestOffset
        !AND BX, &HFFFF         ; Window offset
        !MOV AL, PixelColor
        !MOV ES:[BX], AL
        !POP ES
    NEXT CurrentX
END SUB