' =============================================================================
' MEMORY.SUB - Memory Management Functions (EMS and VESA)
' =============================================================================
' Contains EMS memory allocation, VESA window management, and memory operations
' =============================================================================

' =============================================================================
' Allocate EMS (Expanded Memory) 
' Parameters:
'   SizeKB - Size in kilobytes to allocate (BYVAL)
'   Handle - Returns EMS handle (BYREF)
' Returns: Nothing (Handle returned by reference)
' Note: Modifies global EMSMemoryContext.Handle and SVGAScreenContext variables
' =============================================================================
SUB Memory_TakeEms(BYVAL sizeKb AS WORD, BYREF handle AS WORD)
    ' EMS Interrupt 67h, Function 43h - Allocate Pages
    REG 1, &H4300
    REG 2, INT(SizeKB / 16) + 1  ' Convert KB to 16KB pages
    CALL INTERRUPT &H67
    handle = REG(4)
    
    ' Get page frame address (Function 41h)
    REG 1, &H4100
    CALL INTERRUPT &H67
    EMSMemoryContext.Handle = handle
    ' Note: PFRAME% global variable still needed for assembly routines
END SUB

' =============================================================================
' Access EMS memory byte
' Parameters:
'   Page - EMS page number (BYVAL)
'   Offset - Offset within page (BYVAL)
'   Value - Value to write, or -1 to read (BYVAL for write, BYREF for read result)
'   Handle - EMS handle (BYVAL)
' Returns: If Value = -1, returns byte value; otherwise writes Value
' Note: Uses assembly for direct memory access
' =============================================================================
SUB Memory_EmsByte(BYVAL page AS WORD, BYVAL offset AS WORD, BYREF value AS INTEGER, BYVAL handle AS WORD)
    DIM TempValue AS WORD, TempOffset AS WORD
    
    ' Switch to correct EMS page if different from current
    IF handle = EMSMemoryContext.OldHandle THEN
        IF page <> EMSMemoryContext.OldPage THEN
            ' Unmap old page
            REG 1, &H4800
            REG 4, EMSMemoryContext.OldHandle
            CALL INTERRUPT &H67
            
            ' Map new page (Function 44h)
            REG 1, &H4400
            REG 2, page
            REG 4, handle
            CALL INTERRUPT &H67
        END IF
    ELSE
        ' Different handle, unmap old and map new
        REG 1, &H4800
        REG 4, EMSMemoryContext.OldHandle
        CALL INTERRUPT &H67
        
        REG 1, &H4400
        REG 2, page
        REG 4, handle
        CALL INTERRUPT &H67
    END IF
    
    ' Update tracking variables
    EMSMemoryContext.OldPage = page
    EMSMemoryContext.OldHandle = handle
    
    TempValue = value
    TempOffset = offset
    
    IF value = -1 THEN
        ' Read operation - assembly code to read byte
        !PUSH ES
        !MOV ES, PFRAME%
        !MOV BX, TempOffset
        !MOV AL, ES:[BX]
        !MOV AH, 0
        !MOV TempValue, AX
        !POP ES
        value = TempValue
    ELSE
        ' Write operation - assembly code to write byte
        !PUSH ES
        !MOV ES, PFRAME%
        !MOV BX, TempOffset
        !MOV AX, TempValue
        !MOV ES:[BX], AL
        !POP ES
    END IF
END SUB

' =============================================================================
' Write string to EMS memory
' Parameters:
'   Segment - EMS segment (BYVAL)
'   Offset - Offset within segment (BYVAL)
'   Data - String to write (BYREF)
'   Handle - EMS handle (BYVAL)
' Returns: Nothing
' =============================================================================
SUB Memory_PutEmsString(BYVAL segment AS WORD, BYVAL offset AS WORD, BYVAL data AS STRING, BYVAL handle AS WORD)
    DIM Index AS WORD, CurrentByte AS INTEGER
    
    FOR Index = 1 TO LEN(data)
        CurrentByte = ASC(MID$(data, Index, 1))
        CALL Memory_EmsByte(segment, offset + Index - 1, CurrentByte, handle)
    NEXT Index
END SUB

' =============================================================================
' Read string from EMS memory
' Parameters:
'   Segment - EMS segment (BYVAL)
'   Offset - Offset within segment (BYVAL)
'   Length - Number of bytes to read (BYVAL)
'   Handle - EMS handle (BYVAL)
' Returns: String data read from EMS
' =============================================================================
FUNCTION Memory_GetEmsString$(BYVAL segment AS WORD, BYVAL offset AS WORD, BYVAL length AS WORD, BYVAL handle AS WORD)
    DIM Result AS STRING, Index AS WORD, CurrentByte AS INTEGER
    
    Result = ""
    FOR Index = 0 TO length - 1
        CurrentByte = -1  ' Signal read operation
        CALL Memory_EmsByte(segment, offset + Index, CurrentByte, handle)
        Result = Result + CHR$(CurrentByte)
    NEXT Index
    
    Memory_GetEmsString$ = Result
END FUNCTION

' =============================================================================
' Release EMS memory handle
' Parameters:
'   Handle - EMS handle to release (BYVAL)
' Returns: Nothing
' =============================================================================
SUB Memory_CloseEms(BYVAL handle AS WORD)
    ' EMS Function 45h - Release Handle
    REG 1, &H4500
    REG 4, handle
    CALL INTERRUPT &H67
    
    ' Clear tracking if this was the current handle
    IF handle = EMSMemoryContext.Handle THEN
        EMSMemoryContext.Handle = 0
        EMSMemoryContext.OldHandle = 0
        EMSMemoryContext.OldPage = 0
    END IF
END SUB

' =============================================================================
' Write byte to EMS memory
' Parameters:
'   Segment - EMS segment (BYVAL)
'   Offset - Offset within segment (BYVAL)
'   ByteValue - Byte value to write (BYVAL)
'   Handle - EMS handle (BYVAL)
' Returns: Nothing
' =============================================================================
SUB Memory_PutEmsByte(BYVAL segment AS WORD, BYVAL offset AS WORD, BYVAL byteValue AS BYTE, BYVAL handle AS WORD)
    DIM TempValue AS INTEGER
    TempValue = byteValue
    CALL Memory_EmsByte(segment, offset, TempValue, handle)
END SUB

' =============================================================================
' Read byte from EMS memory
' Parameters:
'   Segment - EMS segment (BYVAL)
'   Offset - Offset within segment (BYVAL)
'   Handle - EMS handle (BYVAL)
' Returns: Byte value read from EMS
' =============================================================================
FUNCTION Memory_GetEmsByte(BYVAL segment AS WORD, BYVAL offset AS WORD, BYVAL handle AS WORD) AS BYTE
    DIM TempValue AS INTEGER
    TempValue = -1  ' Signal read operation
    CALL Memory_EmsByte(segment, offset, TempValue, handle)
    Memory_GetEmsByte = TempValue
END FUNCTION

' =============================================================================
' Set VESA window
' Parameters:
'   WindowNumber - VESA window number to set (BYVAL)
' Returns: Nothing
' Note: Updates global VESASystemContext.Window
' =============================================================================
SUB Memory_SetVesaWindow(BYVAL windowNumber AS WORD)
    !MOV AX,&H4F05
    !XOR BX,BX
    !MOV BL,VESASystemContext.Window
    !MOV DX,windowNumber
    !INT &H10
     
    VESASystemContext.Window = windowNumber
END SUB

' =============================================================================
' Copy memory block between segments
' Parameters:
'   SourceSeg, SourceOff - Source segment and offset (BYVAL)
'   SourceSize - Source size (BYVAL)
'   DestSeg, DestOff - Destination segment and offset (BYVAL)
'   DestSize - Destination size (BYVAL)
'   ByteCount - Number of bytes to copy (BYVAL)
' Returns: Nothing
' Note: Uses assembly for efficient memory copying
' =============================================================================
SUB Memory_MemCopy(BYVAL sourceSeg AS WORD, BYVAL sourceOff AS WORD, BYVAL sourceSize AS WORD, BYVAL destSeg AS WORD, BYVAL destOff AS WORD, BYVAL destSize AS WORD, BYVAL byteCount AS WORD)
    ' Assembly memory copy routine
    !PUSH DS
    !PUSH ES
    !PUSH SI
    !PUSH DI
    !MOV AX, sourceSeg
    !MOV DS, AX
    !MOV SI, sourceOff
    !MOV AX, destSeg
    !MOV ES, AX
    !MOV DI, destOff
    !MOV CX, byteCount
    !CLD
    !REP MOVSB
    !POP DI
    !POP SI
    !POP ES
    !POP DS
END SUB

' =============================================================================
' Swap memory blocks between segments
' Parameters:
'   seg1, off1 - First segment and offset (BYVAL)
'   Size1 - First block size (BYVAL)
'   seg2, off2 - Second segment and offset (BYVAL)
'   Size2 - Second block size (BYVAL)
'   ByteCount - Number of bytes to swap (BYVAL)
' Returns: Nothing
' =============================================================================
SUB Memory_MemSwap(BYVAL seg1 AS WORD, BYVAL off1 AS WORD, BYVAL size1 AS WORD, BYVAL seg2 AS WORD, BYVAL off2 AS WORD, BYVAL size2 AS WORD, BYVAL byteCount AS WORD)
    DIM Index AS WORD, Temp1 AS BYTE, Temp2 AS BYTE
    
    ' Simple byte-by-byte swap (could be optimized with assembly)
    FOR Index = 0 TO byteCount - 1
        ' Read bytes from both locations
        !PUSH DS
        !MOV AX, seg1
        !MOV DS, AX
        !MOV BX, off1
        !ADD BX, Index
        !MOV AL, [BX]
        !MOV Temp1, AL
        !MOV AX, seg2
        !MOV DS, AX
        !MOV BX, off2
        !ADD BX, Index
        !MOV AL, [BX]
        !MOV Temp2, AL
        !POP DS
        
        ' Write swapped bytes
        !PUSH DS
        !MOV AX, seg1
        !MOV DS, AX
        !MOV BX, off1
        !ADD BX, Index
        !MOV AL, Temp2
        !MOV [BX], AL
        !MOV AX, seg2
        !MOV DS, AX
        !MOV BX, off2
        !ADD BX, Index
        !MOV AL, Temp1
        !MOV [BX], AL
        !POP DS
    NEXT Index
END SUB

SUB Memory_ClearVideoMemory(BYVAL color as BYTE)
	!PUSH ES
	!MOV AX, &HA000
	!MOV BL, color
	!MOV BH, BL
	!MOV ES, AX
	!XOR CL, CL
	!MOV CH, 16
Loop:
	!STOSW
	!STOSW
	!STOSW
	!STOSW
	!STOSW
	!STOSW
	!STOSW
	!STOSW
	!DEC CL
	!JNZ Loop
	!DEC CH
	!JNZ Loop
	!POP ES
END SUB