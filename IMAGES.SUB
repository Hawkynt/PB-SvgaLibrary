' =============================================================================
' IMAGES.SUB - Image Loading and Display Functions
' =============================================================================
' Contains functions for loading and displaying BMP, PCX, ICO, and ANI files
' =============================================================================

' =============================================================================
' Display a BMP (Windows Bitmap) file
' Parameters:
'   FileName - Path to BMP file (BYREF)
'   X, Y - Display coordinates (BYVAL)
' Returns: Nothing
' Note: Supports 4-bit (16 color), 8-bit (256 color) BMP files
'       Automatically sets palette for 8-bit images
'       Updates global ImageSystemContext
' =============================================================================
SUB SHOWBMP (BYREF FileName AS STRING, BYVAL X AS WORD, BYVAL Y AS WORD)
    DIM FileHandle AS INTEGER, HeaderData AS STRING
    DIM DataOffset AS LONG, ImageWidth AS LONG, ImageHeight AS LONG
    DIM ColorDepth AS WORD, NumColors AS WORD
    DIM ScanlineData AS STRING, PixelX AS WORD, PixelY AS WORD
    DIM PaletteIndex AS WORD, BytesPerLine AS WORD
    
    ' Open BMP file
    FileHandle = FREEFILE
    OPEN FileName FOR BINARY AS #FileHandle
    
    ' Read data offset (offset 0x0A, 4 bytes)
    SEEK FileHandle, &HA
    GET$ FileHandle, 4, HeaderData
    DataOffset = ASC(MID$(HeaderData, 1, 1)) + 256& * ASC(MID$(HeaderData, 2, 1)) + 65536& * ASC(MID$(HeaderData, 3, 1)) + 16777216& * ASC(MID$(HeaderData, 4, 1))
    
    ' Read image width (offset 0x12, 4 bytes)
    SEEK FileHandle, &H12
    GET$ FileHandle, 4, HeaderData
    ImageWidth = ASC(MID$(HeaderData, 1, 1)) + 256& * ASC(MID$(HeaderData, 2, 1)) + 65536& * ASC(MID$(HeaderData, 3, 1)) + 16777216& * ASC(MID$(HeaderData, 4, 1))
    
    ' Read image height (offset 0x16, 4 bytes)
    GET$ FileHandle, 4, HeaderData
    ImageHeight = ASC(MID$(HeaderData, 1, 1)) + 256& * ASC(MID$(HeaderData, 2, 1)) + 65536& * ASC(MID$(HeaderData, 3, 1)) + 16777216& * ASC(MID$(HeaderData, 4, 1))
    
    ' Read color depth (offset 0x1C, 2 bytes)
    SEEK FileHandle, &H1C
    GET$ FileHandle, 2, HeaderData
    ColorDepth = ASC(MID$(HeaderData, 1, 1)) + 256 * ASC(MID$(HeaderData, 2, 1))
    NumColors = 2 ^ ColorDepth
    
    ' Update image context
    ImageSystemContext.X1 = 0
    ImageSystemContext.Y1 = 0
    ImageSystemContext.X2 = ImageWidth - 1
    ImageSystemContext.Y2 = ImageHeight - 1
    ImageSystemContext.XScreen = ImageWidth
    ImageSystemContext.YScreen = ImageHeight
    ImageSystemContext.BitsPerPixel = ColorDepth
    
    ' Load palette for 8-bit images
    IF ColorDepth = 8 THEN
        SEEK FileHandle, &H36
        FOR PaletteIndex = 0 TO NumColors - 1
            DIM Blue AS STRING, Green AS STRING, Red AS STRING, Reserved AS STRING
            GET$ FileHandle, 1, Blue
            GET$ FileHandle, 1, Green
            GET$ FileHandle, 1, Red
            GET$ FileHandle, 1, Reserved
            
            ' Set VGA palette (convert from 8-bit to 6-bit values)
            OUT &H3C8, PaletteIndex
            OUT &H3C9, ASC(Red) * 63 \ 255
            OUT &H3C9, ASC(Green) * 63 \ 255
            OUT &H3C9, ASC(Blue) * 63 \ 255
        NEXT PaletteIndex
    END IF
    
    ' Seek to image data
    SEEK FileHandle, DataOffset
    
    ' Adjust width for word alignment issues in some BMPs
    BytesPerLine = ImageWidth
    IF ImageWidth = 30 THEN BytesPerLine = BytesPerLine + 2
    IF ImageWidth = 15 THEN BytesPerLine = BytesPerLine + 1
    
    ' Display image data based on color depth
    SELECT CASE ColorDepth
        CASE 8  ' 256 colors
            PixelY = ImageHeight - 1  ' BMPs are stored bottom-up
            DO
                GET$ FileHandle, BytesPerLine, ScanlineData
                FOR PixelX = 0 TO BytesPerLine - 1
                    IF VESASystemContext.BMPMode = 0 THEN
                        ' Normal display mode
                        CALL PUTPIXEL(PixelX + X, PixelY + Y, ASC(MID$(ScanlineData, PixelX + 1, 1)))
                    ELSE
                        ' Clipped display mode
                        IF PixelX >= ImageSystemContext.X1 AND PixelX <= ImageSystemContext.X2 AND PixelY >= ImageSystemContext.Y1 AND PixelY <= ImageSystemContext.Y2 THEN
                            CALL PUTPIXEL(PixelX + X - ImageSystemContext.X1, PixelY + Y - ImageSystemContext.Y1, ASC(MID$(ScanlineData, PixelX + 1, 1)))
                        END IF
                    END IF
                NEXT PixelX
                PixelY = PixelY - 1
            LOOP UNTIL PixelY < 0
            
        CASE 4  ' 16 colors
            PixelY = ImageHeight - 1
            DO
                DIM PackedBytesPerLine AS WORD
                PackedBytesPerLine = INT(BytesPerLine / 2) + 2
                GET$ FileHandle, PackedBytesPerLine, ScanlineData
                
                FOR PixelX = 0 TO PackedBytesPerLine - 3
                    DIM PackedByte AS BYTE
                    PackedByte = ASC(MID$(ScanlineData, PixelX + 1, 1))
                    
                    ' Extract two 4-bit pixels from each byte
                    CALL PUTPIXEL(PixelX * 2 + 0 + X, PixelY + Y, PackedByte MOD 16)        ' Lower nibble
                    CALL PUTPIXEL(PixelX * 2 + 1 + X, PixelY + Y, PackedByte \ 16)         ' Upper nibble
                NEXT PixelX
                PixelY = PixelY - 1
            LOOP UNTIL PixelY < 0
    END SELECT
    
    CLOSE FileHandle
END SUB

' =============================================================================
' Display a PCX (ZSoft Paintbrush) file
' Parameters:
'   FileName - Path to PCX file (BYREF)
'   X, Y - Display coordinates (BYVAL)
' Returns: Nothing
' Note: Supports RLE-compressed PCX files
'       Automatically loads and sets 256-color palette
' =============================================================================
SUB SHOWPCX (BYREF FileName AS STRING, BYVAL X AS WORD, BYVAL Y AS WORD)
    DIM FileHandle AS INTEGER, HeaderData AS STRING
    DIM XMin AS WORD, YMin AS WORD, XMax AS WORD, YMax AS WORD
    DIM ImageWidth AS WORD, ImageHeight AS WORD
    DIM PaletteData AS STRING, PaletteIndex AS WORD
    DIM CurrentByte AS BYTE, RunLength AS BYTE, RunValue AS BYTE
    DIM PixelX AS WORD, PixelY AS WORD, CurrentX AS WORD
    
    ' Open PCX file
    FileHandle = FREEFILE
    OPEN FileName FOR BINARY AS #FileHandle
    
    ' Read PCX header (first 128 bytes)
    GET$ FileHandle, 128, HeaderData
    
    ' Extract image dimensions from header
    XMin = ASC(MID$(HeaderData, 5, 1)) + 256 * ASC(MID$(HeaderData, 6, 1))
    YMin = ASC(MID$(HeaderData, 7, 1)) + 256 * ASC(MID$(HeaderData, 8, 1))
    XMax = ASC(MID$(HeaderData, 9, 1)) + 256 * ASC(MID$(HeaderData, 10, 1))
    YMax = ASC(MID$(HeaderData, 11, 1)) + 256 * ASC(MID$(HeaderData, 12, 1))
    
    ImageWidth = XMax - XMin + 1
    ImageHeight = YMax - YMin + 1
    
    ' Update image context
    ImageSystemContext.XScreen = ImageWidth
    ImageSystemContext.YScreen = ImageHeight
    ImageSystemContext.BitsPerPixel = 8
    
    ' Seek to palette (last 768 bytes of file)
    SEEK FileHandle, LOF(FileHandle) - 767
    
    ' Load 256-color palette
    FOR PaletteIndex = 0 TO 255
        DIM Red AS STRING, Green AS STRING, Blue AS STRING
        GET$ FileHandle, 1, Red
        GET$ FileHandle, 1, Green
        GET$ FileHandle, 1, Blue
        
        ' Set VGA palette
        OUT &H3C8, PaletteIndex
        OUT &H3C9, ASC(Red) \ 4      ' Convert from 8-bit to 6-bit
        OUT &H3C9, ASC(Green) \ 4
        OUT &H3C9, ASC(Blue) \ 4
    NEXT PaletteIndex
    
    ' Seek back to image data (after 128-byte header)
    SEEK FileHandle, 129
    
    ' Decode RLE-compressed image data
    CurrentX = 0
    FOR PixelY = 0 TO ImageHeight - 1
        CurrentX = 0
        
        DO WHILE CurrentX < ImageWidth
            DIM ByteData AS STRING
            GET$ FileHandle, 1, ByteData
            CurrentByte = ASC(ByteData)
            
            IF CurrentByte >= 192 THEN
                ' RLE run length byte
                RunLength = CurrentByte - 192
                GET$ FileHandle, 1, ByteData
                RunValue = ASC(ByteData)
                
                ' Output run of pixels
                FOR RunLength = 1 TO (CurrentByte - 192)
                    IF CurrentX < ImageWidth THEN
                        CALL PUTPIXEL(CurrentX + X, PixelY + Y, RunValue)
                        CurrentX = CurrentX + 1
                    END IF
                NEXT RunLength
            ELSE
                ' Single pixel value
                IF CurrentX < ImageWidth THEN
                    CALL PUTPIXEL(CurrentX + X, PixelY + Y, CurrentByte)
                    CurrentX = CurrentX + 1
                END IF
            END IF
        LOOP
    NEXT PixelY
    
    CLOSE FileHandle
END SUB

' =============================================================================
' Display an ICO (Windows Icon) file
' Parameters:
'   FileName - Path to ICO file (BYREF)
'   X, Y - Display coordinates (BYVAL)
' Returns: Nothing
' Note: Displays the first icon in the file (ICO files can contain multiple icons)
'       Supports 16-color and 256-color icons
' =============================================================================
SUB SHOWICON (BYREF FileName AS STRING, BYVAL X AS WORD, BYVAL Y AS WORD)
    DIM FileHandle AS INTEGER, HeaderData AS STRING
    DIM IconCount AS WORD, IconWidth AS BYTE, IconHeight AS BYTE
    DIM ColorCount AS BYTE, DataOffset AS LONG, DataSize AS LONG
    DIM PaletteIndex AS WORD, ScanlineData AS STRING
    DIM PixelX AS WORD, PixelY AS WORD, BytesPerLine AS WORD
    
    ' Open ICO file
    FileHandle = FREEFILE
    OPEN FileName FOR BINARY AS #FileHandle
    
    ' Read ICO header (6 bytes)
    GET$ FileHandle, 6, HeaderData
    IconCount = ASC(MID$(HeaderData, 5, 1)) + 256 * ASC(MID$(HeaderData, 6, 1))
    
    ' Read first icon directory entry (16 bytes)
    GET$ FileHandle, 16, HeaderData
    IconWidth = ASC(MID$(HeaderData, 1, 1))
    IconHeight = ASC(MID$(HeaderData, 2, 1))
    ColorCount = ASC(MID$(HeaderData, 3, 1))
    
    ' Extract data offset and size
    DataOffset = ASC(MID$(HeaderData, 13, 1)) + 256& * ASC(MID$(HeaderData, 14, 1)) + 65536& * ASC(MID$(HeaderData, 15, 1)) + 16777216& * ASC(MID$(HeaderData, 16, 1))
    DataSize = ASC(MID$(HeaderData, 9, 1)) + 256& * ASC(MID$(HeaderData, 10, 1)) + 65536& * ASC(MID$(HeaderData, 11, 1)) + 16777216& * ASC(MID$(HeaderData, 12, 1))
    
    ' Handle 0 values (256x256 or 256 colors)
    IF IconWidth = 0 THEN IconWidth = 256
    IF IconHeight = 0 THEN IconHeight = 256
    IF ColorCount = 0 THEN ColorCount = 256
    
    ' Update image context
    ImageSystemContext.XScreen = IconWidth
    ImageSystemContext.YScreen = IconHeight
    ImageSystemContext.ColorDepth = ColorCount
    
    ' Seek to icon data
    SEEK FileHandle, DataOffset + 1
    
    ' Skip DIB header (40 bytes) and load palette
    SEEK FileHandle, DataOffset + 41
    
    ' Load palette if present
    IF ColorCount <= 256 THEN
        FOR PaletteIndex = 0 TO ColorCount - 1
            DIM Blue AS STRING, Green AS STRING, Red AS STRING, Reserved AS STRING
            GET$ FileHandle, 1, Blue
            GET$ FileHandle, 1, Green
            GET$ FileHandle, 1, Red
            GET$ FileHandle, 1, Reserved
            
            ' Set VGA palette
            OUT &H3C8, PaletteIndex
            OUT &H3C9, ASC(Red) \ 4
            OUT &H3C9, ASC(Green) \ 4
            OUT &H3C9, ASC(Blue) \ 4
        NEXT PaletteIndex
    END IF
    
    ' Calculate bytes per line (must be DWORD aligned)
    IF ColorCount = 16 THEN
        BytesPerLine = ((IconWidth + 1) \ 2 + 3) AND &HFFFC
    ELSE
        BytesPerLine = (IconWidth + 3) AND &HFFFC
    END IF
    
    ' Display icon data (bottom-up like BMP)
    FOR PixelY = IconHeight - 1 TO 0 STEP -1
        GET$ FileHandle, BytesPerLine, ScanlineData
        
        IF ColorCount = 16 THEN
            ' 4-bit color (16 colors)
            FOR PixelX = 0 TO (IconWidth - 1) \ 2
                DIM PackedByte AS BYTE
                PackedByte = ASC(MID$(ScanlineData, PixelX + 1, 1))
                
                ' Draw two pixels from packed byte
                IF PixelX * 2 < IconWidth THEN
                    CALL PUTPIXEL(PixelX * 2 + X, PixelY + Y, PackedByte \ 16)         ' Upper nibble
                END IF
                IF PixelX * 2 + 1 < IconWidth THEN
                    CALL PUTPIXEL(PixelX * 2 + 1 + X, PixelY + Y, PackedByte MOD 16)   ' Lower nibble
                END IF
            NEXT PixelX
        ELSE
            ' 8-bit color (256 colors)
            FOR PixelX = 0 TO IconWidth - 1
                CALL PUTPIXEL(PixelX + X, PixelY + Y, ASC(MID$(ScanlineData, PixelX + 1, 1)))
            NEXT PixelX
        END IF
    NEXT PixelY
    
    CLOSE FileHandle
END SUB

' =============================================================================
' Get BMP file dimensions without loading the image
' Parameters:
'   FileName - Path to BMP file (BYREF)
'   Width - Returns image width (BYREF)
'   Height - Returns image height (BYREF)
' Returns: Width and Height by reference
' =============================================================================
SUB GETBMPSIZE(BYREF FileName AS STRING, BYREF Width AS WORD, BYREF Height AS WORD)
    DIM FileHandle AS INTEGER, HeaderData AS STRING
    
    ' Open BMP file
    FileHandle = FREEFILE
    OPEN FileName FOR BINARY AS #FileHandle
    
    ' Read image width (offset 0x12, 4 bytes)
    SEEK FileHandle, &H12
    GET$ FileHandle, 4, HeaderData
    Width = ASC(MID$(HeaderData, 1, 1)) + 256 * ASC(MID$(HeaderData, 2, 1))
    
    ' Read image height (offset 0x16, 4 bytes)
    GET$ FileHandle, 4, HeaderData
    Height = ASC(MID$(HeaderData, 1, 1)) + 256 * ASC(MID$(HeaderData, 2, 1))
    
    CLOSE FileHandle
END SUB

' =============================================================================
' Extract palette from BMP file
' Parameters:
'   FileName - Path to BMP file (BYREF)
'   Palette - Array to store palette data (BYREF)
'   ColorDepth - Color depth in bits (BYVAL)
' Returns: Palette data in array
' Note: Palette array should be dimensioned as (0 TO 255, 0 TO 2) for RGB values
' =============================================================================
SUB GETBMPPAL (BYREF FileName AS STRING, BYREF Palette() AS BYTE, BYVAL ColorDepth AS BYTE)
    DIM FileHandle AS INTEGER, NumColors AS WORD, PaletteIndex AS WORD
    DIM Blue AS STRING, Green AS STRING, Red AS STRING, Reserved AS STRING
    
    ' Calculate number of colors
    NumColors = 2 ^ ColorDepth
    IF NumColors > 256 THEN NumColors = 256
    
    ' Open BMP file
    FileHandle = FREEFILE
    OPEN FileName FOR BINARY AS #FileHandle
    
    ' Seek to palette (offset 0x36 for most BMPs)
    SEEK FileHandle, &H36
    
    ' Read palette entries
    FOR PaletteIndex = 0 TO NumColors - 1
        GET$ FileHandle, 1, Blue
        GET$ FileHandle, 1, Green
        GET$ FileHandle, 1, Red
        GET$ FileHandle, 1, Reserved
        
        ' Store RGB values in array
        Palette(PaletteIndex, 0) = ASC(Red)
        Palette(PaletteIndex, 1) = ASC(Green)
        Palette(PaletteIndex, 2) = ASC(Blue)
    NEXT PaletteIndex
    
    CLOSE FileHandle
END SUB