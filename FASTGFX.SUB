' =============================================================================
' FASTGFX.SUB - Optimized Graphics Operations
' =============================================================================
' Contains optimized drawing functions for multiple pixels, block operations,
' and fast assembly routines compatible with 8086 processors
' =============================================================================

' =============================================================================
' Fast horizontal line drawing (optimized for both VGA and Mode-X)
' Parameters:
'   X1, X2 - Start and end X coordinates (BYVAL)
'   Y - Y coordinate (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' Note: Automatically detects Mode-X and uses appropriate optimized routine
' =============================================================================
SUB FASTHLINE(BYVAL X1 AS WORD, BYVAL X2 AS WORD, BYVAL Y AS WORD, BYVAL Color AS BYTE)
    ' Ensure X1 <= X2
    IF X1 > X2 THEN SWAP X1, X2
    
    ' Check if Mode-X is active
    IF VESASystemContext.CurrentMode = %SVGA_MODEX THEN
        CALL HLINEMODEX(X1, X2, Y, Color)
    ELSE
        ' Standard VGA Mode 13h optimization
        CALL FastHLineVGA(X1, X2, Y, Color)
    END IF
END SUB

' =============================================================================
' Fast horizontal line for standard VGA modes
' Parameters:
'   X1, X2 - Start and end X coordinates (BYVAL)
'   Y - Y coordinate (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' Note: Optimized for 320x200x256 and linear VGA modes
' =============================================================================
SUB FastHLineVGA(BYVAL X1 AS WORD, BYVAL X2 AS WORD, BYVAL Y AS WORD, BYVAL Color AS BYTE)
    DIM StartOffset AS WORD, LineLength AS WORD
    
    StartOffset = Y * SVGAScreenContext.BytesPerLine + X1
    LineLength = X2 - X1 + 1
    
    ' Use 8086-compatible fast fill
    !PUSH ES
    !MOV AX, &HA000
    !MOV ES, AX
    !MOV BX, StartOffset
    !MOV AL, Color
    !MOV CX, LineLength
    
    ' Fast fill loop (8086 compatible)
    FillHLine:
    !MOV ES:[BX], AL
    !INC BX
    !LOOP FillHLine
    
    !POP ES
END SUB

' =============================================================================
' Fast vertical line drawing
' Parameters:
'   X - X coordinate (BYVAL)
'   Y1, Y2 - Start and end Y coordinates (BYVAL)
'   Color - Line color (BYVAL)
' Returns: Nothing
' Note: Optimized for both VGA and Mode-X modes
' =============================================================================
SUB FASTVLINE(BYVAL X AS WORD, BYVAL Y1 AS WORD, BYVAL Y2 AS WORD, BYVAL Color AS BYTE)
    DIM CurrentY AS WORD, BytesPerLine AS WORD, StartOffset AS WORD
    
    ' Ensure Y1 <= Y2
    IF Y1 > Y2 THEN SWAP Y1, Y2
    
    IF VESASystemContext.CurrentMode = %SVGA_MODEX THEN
        ' Mode-X vertical line
        FOR CurrentY = Y1 TO Y2
            CALL PUTPIXELMODEX(X, CurrentY, Color)
        NEXT CurrentY
    ELSE
        ' Standard VGA vertical line (optimized)
        BytesPerLine = SVGAScreenContext.BytesPerLine
        StartOffset = Y1 * BytesPerLine + X
        
        !PUSH ES
        !MOV AX, &HA000
        !MOV ES, AX
        !MOV BX, StartOffset
        !MOV AL, Color
        !MOV DX, BytesPerLine
        !MOV CX, Y2
        !SUB CX, Y1
        !INC CX                 ; Include end point
        
        ' Fast vertical line loop
        VLineLoop:
        !MOV ES:[BX], AL
        !ADD BX, DX             ; Move to next scanline
        !LOOP VLineLoop
        
        !POP ES
    END IF
END SUB

' =============================================================================
' Fast filled rectangle (optimized block fill)
' Parameters:
'   X1, Y1 - Top-left corner (BYVAL)
'   X2, Y2 - Bottom-right corner (BYVAL)
'   Color - Fill color (BYVAL)
' Returns: Nothing
' Note: Much faster than pixel-by-pixel drawing
' =============================================================================
SUB FASTFILLRECT(BYVAL X1 AS WORD, BYVAL Y1 AS WORD, BYVAL X2 AS WORD, BYVAL Y2 AS WORD, BYVAL Color AS BYTE)
    DIM CurrentY AS WORD
    
    ' Ensure coordinates are ordered
    IF X1 > X2 THEN SWAP X1, X2
    IF Y1 > Y2 THEN SWAP Y1, Y2
    
    ' Draw horizontal lines for each scanline
    FOR CurrentY = Y1 TO Y2
        CALL FASTHLINE(X1, X2, CurrentY, Color)
    NEXT CurrentY
END SUB

' =============================================================================
' Fast block copy with 8086-optimized assembly
' Parameters:
'   SrcX, SrcY - Source coordinates (BYVAL)
'   DestX, DestY - Destination coordinates (BYVAL)
'   Width, Height - Block dimensions (BYVAL)
' Returns: Nothing
' Note: Uses optimized assembly for maximum speed on 8086+
' =============================================================================
SUB FASTBLOCKXOPY(BYVAL SrcX AS WORD, BYVAL SrcY AS WORD, BYVAL DestX AS WORD, BYVAL DestY AS WORD, BYVAL Width AS WORD, BYVAL Height AS WORD)
    IF VESASystemContext.CurrentMode = %SVGA_MODEX THEN
        ' Use Mode-X optimized copy
        CALL COPYBLOCKMODEX(SrcX, SrcY, DestX, DestY, Width, Height)
    ELSE
        ' Standard VGA block copy
        CALL FastBlockCopyVGA(SrcX, SrcY, DestX, DestY, Width, Height)
    END IF
END SUB

' =============================================================================
' Fast VGA block copy (8086 optimized)
' Parameters:
'   SrcX, SrcY - Source coordinates (BYVAL)
'   DestX, DestY - Destination coordinates (BYVAL)
'   Width, Height - Block dimensions (BYVAL)
' Returns: Nothing
' =============================================================================
SUB FastBlockCopyVGA(BYVAL SrcX AS WORD, BYVAL SrcY AS WORD, BYVAL DestX AS WORD, BYVAL DestY AS WORD, BYVAL Width AS WORD, BYVAL Height AS WORD)
    DIM CurrentY AS WORD, SrcOffset AS WORD, DestOffset AS WORD
    DIM BytesPerLine AS WORD, CopyDirection AS INTEGER
    
    BytesPerLine = SVGAScreenContext.BytesPerLine
    
    ' Determine copy direction to handle overlapping regions
    IF SrcY < DestY OR (SrcY = DestY AND SrcX < DestX) THEN
        ' Copy backwards (bottom to top, right to left)
        CopyDirection = -1
        CurrentY = Height - 1
    ELSE
        ' Copy forwards (top to bottom, left to right)
        CopyDirection = 1
        CurrentY = 0
    END IF
    
    !PUSH ES
    !PUSH DS
    !MOV AX, &HA000
    !MOV ES, AX
    !MOV DS, AX
    
    IF CopyDirection = 1 THEN
        ' Forward copy
        DO WHILE CurrentY < Height
            SrcOffset = (SrcY + CurrentY) * BytesPerLine + SrcX
            DestOffset = (DestY + CurrentY) * BytesPerLine + DestX
            
            !MOV SI, SrcOffset
            !MOV DI, DestOffset
            !MOV CX, Width
            !CLD                    ; Clear direction flag (forward)
            
            ' 8086-compatible block move
            ForwardCopyLoop:
            !LODSB                  ; Load byte from DS:SI into AL, increment SI
            !STOSB                  ; Store AL to ES:DI, increment DI
            !LOOP ForwardCopyLoop
            
            CurrentY = CurrentY + 1
        LOOP
    ELSE
        ' Backward copy
        DO WHILE CurrentY >= 0
            SrcOffset = (SrcY + CurrentY) * BytesPerLine + SrcX + Width - 1
            DestOffset = (DestY + CurrentY) * BytesPerLine + DestX + Width - 1
            
            !MOV SI, SrcOffset
            !MOV DI, DestOffset
            !MOV CX, Width
            !STD                    ; Set direction flag (backward)
            
            ' 8086-compatible backward block move
            BackwardCopyLoop:
            !LODSB                  ; Load byte from DS:SI, decrement SI
            !STOSB                  ; Store AL to ES:DI, decrement DI
            !LOOP BackwardCopyLoop
            
            CurrentY = CurrentY - 1
        LOOP
        
        !CLD                        ; Restore forward direction
    END IF
    
    !POP DS
    !POP ES
END SUB

' =============================================================================
' Fast pattern fill (optimized for repeating patterns)
' Parameters:
'   X1, Y1 - Top-left corner (BYVAL)
'   X2, Y2 - Bottom-right corner (BYVAL)
'   Pattern - Pattern string (BYREF)
'   PatternWidth - Width of pattern in pixels (BYVAL)
' Returns: Nothing
' Note: Fills area with repeating pattern, optimized for speed
' =============================================================================
SUB FASTPATTERNFILL(BYVAL X1 AS WORD, BYVAL Y1 AS WORD, BYVAL X2 AS WORD, BYVAL Y2 AS WORD, BYVAL Pattern AS STRING, BYVAL PatternWidth AS BYTE)
    DIM CurrentY AS WORD, CurrentX AS WORD, PatternY AS WORD, PatternX AS WORD
    DIM PatternHeight AS BYTE, PixelColor AS BYTE
    
    ' Calculate pattern dimensions
    PatternHeight = LEN(Pattern) \ PatternWidth
    IF PatternHeight = 0 THEN EXIT SUB
    
    ' Ensure coordinates are ordered
    IF X1 > X2 THEN SWAP X1, X2
    IF Y1 > Y2 THEN SWAP Y1, Y2
    
    ' Fill area with pattern
    FOR CurrentY = Y1 TO Y2
        PatternY = (CurrentY - Y1) MOD PatternHeight
        
        FOR CurrentX = X1 TO X2
            PatternX = (CurrentX - X1) MOD PatternWidth
            PixelColor = ASC(MID$(Pattern, PatternY * PatternWidth + PatternX + 1, 1))
            
            IF VESASystemContext.CurrentMode = %SVGA_MODEX THEN
                CALL PUTPIXELMODEX(CurrentX, CurrentY, PixelColor)
            ELSE
                CALL PUTPIXEL(CurrentX, CurrentY, PixelColor)
            END IF
        NEXT CurrentX
    NEXT CurrentY
END SUB

' =============================================================================
' Fast sprite drawing with transparency (8086 optimized)
' Parameters:
'   X, Y - Sprite position (BYVAL)
'   SpriteData - Sprite pixel data (BYREF)
'   Width, Height - Sprite dimensions (BYVAL)
'   TransColor - Transparent color index (BYVAL)
' Returns: Nothing
' Note: Skips transparent pixels for fast masked sprite drawing
' =============================================================================
SUB FASTSPRITE(BYVAL X AS WORD, BYVAL Y AS WORD, BYVAL SpriteData AS STRING, BYVAL Width AS BYTE, BYVAL Height AS BYTE, BYVAL TransColor AS BYTE)
    DIM CurrentY AS WORD, CurrentX AS WORD, PixelIndex AS WORD, PixelColor AS BYTE
    
    PixelIndex = 1
    FOR CurrentY = 0 TO Height - 1
        FOR CurrentX = 0 TO Width - 1
            IF PixelIndex <= LEN(SpriteData) THEN
                PixelColor = ASC(MID$(SpriteData, PixelIndex, 1))
                
                ' Only draw non-transparent pixels
                IF PixelColor <> TransColor THEN
                    IF VESASystemContext.CurrentMode = %SVGA_MODEX THEN
                        CALL PUTPIXELMODEX(X + CurrentX, Y + CurrentY, PixelColor)
                    ELSE
                        CALL PUTPIXEL(X + CurrentX, Y + CurrentY, PixelColor)
                    END IF
                END IF
                
                PixelIndex = PixelIndex + 1
            END IF
        NEXT CurrentX
    NEXT CurrentY
END SUB

' =============================================================================
' Fast block memory move with 8086 optimization
' Parameters:
'   SourceSeg - Source segment (BYVAL)
'   SourceOff - Source offset (BYVAL)
'   DestSeg - Destination segment (BYVAL)
'   DestOff - Destination offset (BYVAL)
'   ByteCount - Number of bytes to move (BYVAL)
' Returns: Nothing
' Note: Optimized for 8086 with word-aligned transfers when possible
' =============================================================================
SUB FASTMEMMOVE(BYVAL SourceSeg AS WORD, BYVAL SourceOff AS WORD, BYVAL DestSeg AS WORD, BYVAL DestOff AS WORD, BYVAL ByteCount AS WORD)
    DIM WordCount AS WORD, RemainderBytes AS WORD
    
    ' Calculate word-aligned transfer for speed
    WordCount = ByteCount \ 2
    RemainderBytes = ByteCount MOD 2
    
    !PUSH DS
    !PUSH ES
    !PUSH SI
    !PUSH DI
    
    !MOV AX, SourceSeg
    !MOV DS, AX
    !MOV SI, SourceOff
    !MOV AX, DestSeg
    !MOV ES, AX
    !MOV DI, DestOff
    !CLD                        ; Clear direction flag
    
    ' Move words first (faster on 8086)
    IF WordCount > 0 THEN
        !MOV CX, WordCount
        
        WordMoveLoop:
        !LODSW                  ; Load word from DS:SI into AX, add 2 to SI
        !STOSW                  ; Store AX to ES:DI, add 2 to DI
        !LOOP WordMoveLoop
    END IF
    
    ' Move remaining bytes
    IF RemainderBytes > 0 THEN
        !MOV CX, RemainderBytes
        
        ByteMoveLoop:
        !LODSB                  ; Load byte from DS:SI into AL, increment SI
        !STOSB                  ; Store AL to ES:DI, increment DI
        !LOOP ByteMoveLoop
    END IF
    
    !POP DI
    !POP SI
    !POP ES
    !POP DS
END SUB

' =============================================================================
' Fast screen scroll (optimized for animation and scrolling games)
' Parameters:
'   Direction - Scroll direction: 0=up, 1=down, 2=left, 3=right (BYVAL)
'   ScrollAmount - Number of pixels to scroll (BYVAL)
'   FillColor - Color to fill exposed area (BYVAL)
' Returns: Nothing
' Note: Very fast scrolling using optimized block moves
' =============================================================================
SUB FASTSCROLL(BYVAL Direction AS BYTE, BYVAL ScrollAmount AS WORD, BYVAL FillColor AS BYTE)
    DIM ScreenWidth AS WORD, ScreenHeight AS WORD
    
    ScreenWidth = SVGAScreenContext.XRes
    ScreenHeight = SVGAScreenContext.YRes
    
    SELECT CASE Direction
        CASE 0  ' Scroll up
            IF ScrollAmount < ScreenHeight THEN
                CALL FASTBLOCKXOPY(0, ScrollAmount, 0, 0, ScreenWidth, ScreenHeight - ScrollAmount)
                CALL FASTFILLRECT(0, ScreenHeight - ScrollAmount, ScreenWidth - 1, ScreenHeight - 1, FillColor)
            ELSE
                CALL FASTFILLRECT(0, 0, ScreenWidth - 1, ScreenHeight - 1, FillColor)
            END IF
            
        CASE 1  ' Scroll down
            IF ScrollAmount < ScreenHeight THEN
                CALL FASTBLOCKXOPY(0, 0, 0, ScrollAmount, ScreenWidth, ScreenHeight - ScrollAmount)
                CALL FASTFILLRECT(0, 0, ScreenWidth - 1, ScrollAmount - 1, FillColor)
            ELSE
                CALL FASTFILLRECT(0, 0, ScreenWidth - 1, ScreenHeight - 1, FillColor)
            END IF
            
        CASE 2  ' Scroll left
            IF ScrollAmount < ScreenWidth THEN
                CALL FASTBLOCKXOPY(ScrollAmount, 0, 0, 0, ScreenWidth - ScrollAmount, ScreenHeight)
                CALL FASTFILLRECT(ScreenWidth - ScrollAmount, 0, ScreenWidth - 1, ScreenHeight - 1, FillColor)
            ELSE
                CALL FASTFILLRECT(0, 0, ScreenWidth - 1, ScreenHeight - 1, FillColor)
            END IF
            
        CASE 3  ' Scroll right
            IF ScrollAmount < ScreenWidth THEN
                CALL FASTBLOCKXOPY(0, 0, ScrollAmount, 0, ScreenWidth - ScrollAmount, ScreenHeight)
                CALL FASTFILLRECT(0, 0, ScrollAmount - 1, ScreenHeight - 1, FillColor)
            ELSE
                CALL FASTFILLRECT(0, 0, ScreenWidth - 1, ScreenHeight - 1, FillColor)
            END IF
    END SELECT
END SUB